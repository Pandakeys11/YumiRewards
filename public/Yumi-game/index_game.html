<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Yumi Pop</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&family=Sawarabi+Mincho&display=swap" rel="stylesheet" />
    <!-- WalletConnect Provider Library -->
    <script src="https://unpkg.com/@walletconnect/web3-provider/dist/umd/index.min.js"></script>
    <!-- Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-database.js"></script>
    <!-- Game Scripts -->
    <script src="bubblePatterns.js"></script>
    <script type="module" src="achievements.js"></script>
    <script type="module" src="player.js"></script>
    <script>
    // Make game objects and classes available globally for bubblePatterns.js
    window.gameObjects = {
        bubbles: [],
        platforms: [],
        player: null,
        projectiles: []
    };
    window.backpackInventory = {};
    window.difficultyFactor = 1.0;
    
    // Initialize Firebase with your config
    var firebaseConfig = {
      apiKey: "AIzaSyAN-37ysgFJlncUZAVH7k79HPSqUZy4FKA",
      authDomain: "yumi-pop.firebaseapp.com",
      databaseURL: "https://yumi-pop-default-rtdb.firebaseio.com",
      projectId: "yumi-pop",
      storageBucket: "yumi-pop.firebasestorage.app",
      messagingSenderId: "328717127716",
      appId: "1:328717127716:web:9c7b5beefda761f8ae48b1",
      measurementId: "G-HHDJD3F9VY"
    };
    firebase.initializeApp(firebaseConfig);

    // Wallet Integration
    let playerWalletAddress = null;

    async function connectWallet() {
        try {
            // Check if already connected
            if (playerWalletAddress) {
                showGameMessage("Wallet already connected!");
                return;
            }

            // Check if MetaMask or other Web3 provider is available
            if (!window.ethereum) {
                showGameMessage("Please install MetaMask or another Web3 wallet!");
                window.open('https://metamask.io/download/', '_blank');
                return;
            }

            // Request account access
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });

            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            
            // Update UI
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            document.getElementById("connectWalletButton").style.display = "none";
            document.getElementById("disconnectWalletButton").style.display = "block";

            // Update Firebase record with wallet address
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }

            showGameMessage("Wallet connected successfully!");

            // Setup event listeners for wallet
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
            window.ethereum.on('disconnect', handleDisconnect);

        } catch (error) {
            console.error("Wallet connect error: ", error);
            document.getElementById("walletAddressDisplay").innerText = "Connection Failed";
            showGameMessage("Failed to connect wallet: " + error.message);
        }
    }

    async function disconnectWallet() {
        try {
            playerWalletAddress = null;

            // Update UI
            document.getElementById("walletAddressDisplay").innerText = "Not Connected";
            document.getElementById("homeProfileWallet").innerText = "Wallet: Not Connected";
            document.getElementById("connectWalletButton").style.display = "block";
            document.getElementById("disconnectWalletButton").style.display = "none";

            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: ""
                });
            }

            showGameMessage("Wallet disconnected");

            // Remove event listeners
            if (window.ethereum) {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
                window.ethereum.removeListener('disconnect', handleDisconnect);
            }
        } catch (error) {
            console.error("Error disconnecting wallet:", error);
        }
    }

    // Wallet event handlers
    function handleAccountsChanged(accounts) {
        if (accounts.length === 0) {
            disconnectWallet();
        } else if (accounts[0] !== playerWalletAddress) {
            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            
            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }
        }
    }

    function handleChainChanged() {
        // Reload the page when chain changes
        window.location.reload();
    }

    function handleDisconnect() {
        disconnectWallet();
    }

    // Add wallet button event listeners
    document.getElementById("connectWalletButton").addEventListener("click", connectWallet);
    document.getElementById("disconnectWalletButton").addEventListener("click", disconnectWallet);

    // Check if already connected on page load
    document.addEventListener('DOMContentLoaded', async () => {
        if (window.ethereum) {
            try {
                const accounts = await window.ethereum.request({ 
                    method: 'eth_accounts' 
                });
                if (accounts.length > 0) {
                    playerWalletAddress = accounts[0];
                    const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
                    document.getElementById("walletAddressDisplay").innerText = shortAddress;
                    document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
                    document.getElementById("connectWalletButton").style.display = "none";
                    document.getElementById("disconnectWalletButton").style.display = "block";
                }
            } catch (error) {
                console.error("Error checking wallet connection:", error);
            }
        }
    });

    // Mobile Touch Controls
    let touchControls = {
        left: false,
        right: false,
        up: false,
        down: false,
        action: false,
        special: false
    };

    function setupTouchControls() {
        const controls = {
            moveLeft: document.getElementById('moveLeft'),
            moveRight: document.getElementById('moveRight'),
            moveUp: document.getElementById('moveUp'),
            moveDown: document.getElementById('moveDown'),
            actionButton: document.getElementById('actionButton'),
            specialButton: document.getElementById('specialButton')
        };

        // Helper function to handle touch events
        function handleTouch(element, action, isStart) {
            if (!element) return;
            
            const handler = (e) => {
                e.preventDefault();
                touchControls[action] = isStart;
                element.style.transform = isStart ? 'scale(0.95)' : 'scale(1)';
                element.style.background = isStart ? 
                    (element.classList.contains('action-button') || element.classList.contains('special-button') ?
                        'rgba(255, 95, 212, 0.4)' : 'rgba(70, 251, 227, 0.4)') :
                    (element.classList.contains('action-button') || element.classList.contains('special-button') ?
                        'rgba(255, 95, 212, 0.2)' : 'rgba(70, 251, 227, 0.2)');
            };

            element.addEventListener('touchstart', e => handler(e, true));
            element.addEventListener('touchend', e => handler(e, false));
            element.addEventListener('touchcancel', e => handler(e, false));
        }

        // Setup touch handlers for each control
        handleTouch(controls.moveLeft, 'left');
        handleTouch(controls.moveRight, 'right');
        handleTouch(controls.moveUp, 'up');
        handleTouch(controls.moveDown, 'down');
        handleTouch(controls.actionButton, 'action');
        handleTouch(controls.specialButton, 'special');

        // Handle multitouch
        document.addEventListener('touchstart', handleMultiTouch);
        document.addEventListener('touchmove', handleMultiTouch);
        document.addEventListener('touchend', handleMultiTouch);
        document.addEventListener('touchcancel', handleMultiTouch);
    }

    function handleMultiTouch(e) {
        e.preventDefault();
        
        // Reset all controls
        Object.keys(touchControls).forEach(key => touchControls[key] = false);
        
        // Check each touch point
        Array.from(e.touches).forEach(touch => {
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!element) return;
            
            // Update controls based on touched elements
            if (element.closest('#moveLeft')) touchControls.left = true;
            if (element.closest('#moveRight')) touchControls.right = true;
            if (element.closest('#moveUp')) touchControls.up = true;
            if (element.closest('#moveDown')) touchControls.down = true;
            if (element.closest('#actionButton')) touchControls.action = true;
            if (element.closest('#specialButton')) touchControls.special = true;
        });
    }

    // Update game loop to handle touch controls
    function updateGameWithTouchControls() {
        if (!player || gameState !== GameState.PLAYING) return;

        const speed = player.speed * (touchControls.special ? 1.5 : 1);

        if (touchControls.left) player.moveLeft(speed);
        if (touchControls.right) player.moveRight(speed);
        if (touchControls.up) player.moveUp(speed);
        if (touchControls.down) player.moveDown(speed);
        if (touchControls.action) player.shoot();
        if (touchControls.special) player.useSpecialAbility();
    }

    // Add touch controls update to the game loop
    function gameLoop(timestamp) {
        if (gameState !== GameState.PLAYING) return;
        
        const deltaTime = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        // Update game with touch controls if in mobile mode
        if (document.body.classList.contains('mobile-mode')) {
            updateGameWithTouchControls();
        }

        // Update game state
        updateGame(deltaTime);
        
        // Update UI
        updateUI();
        
        // Request next frame
        requestAnimationFrame(gameLoop);
    }

    // Update UI function to handle mobile UI
    function updateUI() {
        // Update score display
        document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
        
        // Update timer display
        const timeLeft = Math.max(0, Math.ceil(roundTimer));
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        document.getElementById('timerDisplay').textContent = 
            `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Update level display
        document.getElementById('levelDisplay').textContent = `Level: ${currentLevel}`;
        
        // Update health bar
        const healthBar = document.querySelector('.health-fill');
        if (healthBar) {
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
        }
        
        // Update special ability bar
        const specialBar = document.querySelector('.special-fill');
        if (specialBar) {
            specialBar.style.width = `${(player.specialMeter / player.maxSpecialMeter) * 100}%`;
        }
    }

    // Handle screen orientation changes
    function handleOrientationChange() {
        const isLandscape = window.innerWidth > window.innerHeight;
        const message = document.getElementById('orientationMessage') || createOrientationMessage();
        
        if (window.innerWidth <= 768) {
            message.style.display = isLandscape ? 'none' : 'block';
            if (!isLandscape) {
                pauseGame();
            } else if (gameState === GameState.PAUSED) {
                resumeGame();
            }
        } else {
            message.style.display = 'none';
        }
    }

    // Add orientation change listener
    window.addEventListener('orientationchange', handleOrientationChange);
    window.addEventListener('resize', handleOrientationChange);

    // Initialize mobile detection on load
    document.addEventListener('DOMContentLoaded', () => {
        updateViewMode();
        handleOrientationChange();
    });

    </script>
    <style>
        /* Global CSS variables for neon pink/green vibe */
        :root {
            --bg-color: #101010;
            --panel-bg: #2f2f2f;
            --border-color: #e7e7e7;
            --accent-color: #46fbe3;
            --hover-color: #46fbe3;
            --text-color: #ffffff;
            --highlight-color: #ff5fd4;
            --font-anime: 'Bangers', 'Press Start 2P', 'Sawarabi Mincho', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Sawarabi Mincho', serif;
            font-size: 12px;
            overflow: hidden;
            image-rendering: auto;
        }

        header, main, aside {
            display: block;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: buttonHue 5s linear infinite;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            border-color: var(--highlight-color);
        }

        button:active {
            transform: translateY(1px);
        }

        @keyframes buttonHue {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Hue border animation for key UI elements */
        #homeScreenContainer, #walletAndStartSection, #profilePreviewSection, #homeLeaderboard, #itemDirectorySection {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }
        /* Home Screen */
        #startScreen, #cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background-image: url('assets/images/custom-background.png');
            background-repeat: no-repeat;
            background-position: center;
            background-size: cover;
            border: 4px solid var(--border-color);
            box-shadow: 0 0 0 8px #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: border 0.5s ease;
            animation: hueRotate 10s infinite linear;
        }

        #homeScreenContainer {
            width: 90%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            margin: 0 auto;
            height: calc(100vh - 100px);
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        #mainContent {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #itemDirectorySection {
            flex: 0 0 auto;
            margin: 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        #homeLeaderboard {
            flex: 0 0 auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }

        #homeLeaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--accent-color);
        }

        #homeLeaderboardList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .leaderboard-entry {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.8);
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 14px;
            min-width: 30px;
        }

        .leaderboard-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboard-player img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid var(--accent-color);
        }

        .leaderboard-username {
            color: var(--text-color);
            font-size: 14px;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
        }

        #homeInputSection label, #walletAndStartSection label {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
        }

        #homeInputSection input, #walletAndStartSection input, #homeInputSection select {
            padding: 5px;
            font-size: 12px;
            border: 2px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: 5px;
            margin-top: 5px;
        }

        .info-box {
            width: 100%;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #walletAndStartSection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        #profilePreviewSection .profile {
            display: flex;
            gap: 10px;
            align-items: center;
        }

            #profilePreviewSection .profile img {
                width: 50px;
                height: 50px;
                border: 2px solid var(--accent-color);
                border-radius: 50%;
            }

        #profilePreviewSection .profile-info p {
            margin: 2px 0;
        }

        #leaderboardAndItemsWrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }

        #homeLeaderboard, #itemDirectorySection {
            flex: 1;
            min-width: 45%;
        }

        #homeLeaderboard {
            width: 100%;
        }

            #homeLeaderboard h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        #itemDirectorySection {
            width: 100%;
            margin-top: 20px;
        }

            #itemDirectorySection h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #itemDirectoryListHome {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Main Game UI */
        #mainContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            display: none;
            flex-direction: row;
            gap: 0;
            padding: 10px;
        }

            #mainContainer.fullScreen {
                padding: 0;
                flex-direction: column;
            }

                #mainContainer.fullScreen #leftPanel,
                #mainContainer.fullScreen #sidebar,
                #coinPanel {
                    display: none;
                }

        #topButtons {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #topButtons {
            display: flex;
        }

        #topButtons button {
            padding: 8px 15px;
            font-size: 12px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #topButtons button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
        }

        #keyMapOverlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            font-size: 12px;
            color: var(--text-color);
            z-index: 100;
            transition: all 0.3s ease;
            max-height: 40px;
            overflow: hidden;
            cursor: pointer;
        }

        #keyMapOverlay:hover {
            max-height: 200px;
        }

        #keyMapOverlay h4 {
            color: var(--accent-color);
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            min-width: 20px;
            text-align: center;
        }

        #statsBox {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--highlight-color);
            z-index: 100;
            text-align: center;
            transition: all 0.3s ease;
        }

        #backpackHudFullScreen {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
        }

        /* Hover effects for UI elements */
        #topButtons:hover,
        #keyMapOverlay:hover,
        #backpackHudFullScreen:hover,
        #statsBox:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }

        #statsBox:hover {
            transform: translateX(-50%) scale(1.05);
        }

        /* Collapsed key map state */
        #keyMapOverlay::after {
            content: '⌨️ Controls';
            display: block;
            text-align: center;
            padding: 5px;
            font-size: 12px;
            color: var(--accent-color);
        }

        #keyMapOverlay:hover::after {
            display: none;
        }

        /* Game canvas adjustments */
        #mainContainer.fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            border: none;
        }

        /* Ensure UI elements don't interfere with gameplay */
        #gameArea {
            position: relative;
            overflow: hidden;
        }

        /* Mobile-friendly adjustments */
        @media (max-width: 768px) {
            #topButtons,
            #keyMapOverlay,
            #backpackHudFullScreen,
            #statsBox {
                transform: scale(0.8);
                padding: 8px;
            }

            #topButtons {
                right: 10px;
            }

            #keyMapOverlay {
                left: 10px;
            }

            #backpackHudFullScreen {
                bottom: 10px;
            }
        }

        #mainContainer.fullScreen #topButtons button {
            padding: 8px 12px;
            font-size: 10px;
            min-width: 80px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #keyMapOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 10px;
            text-align: left;
            color: var(--text-color);
        }

        #keyMapOverlay h4 {
            margin: 0 0 4px 0;
            font-size: 10px;
        }

        #keyMapOverlay p {
            margin: 2px 0;
            font-size: 9px;
        }

        #backpackHudFullScreen {
            display: none;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            align-items: center;
            z-index: 50;
        }

        #leftPanel, #sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-color);
            box-shadow: 0 0 15px var(--accent-color);
            position: relative;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
        }

        #sidebar {
            text-align: center;
        }

        #sidebar img {
            display: block;
            margin: 15px auto;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .portraitContainer {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid var(--accent-color);
        }

        .portraitContainer img {
            width: 180px;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 4px;
        }

        #keyMap {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-color);
            font-size: 10px;
            text-align: left;
            color: var(--highlight-color);
        }

        #keyMap h4 {
            margin: 0 0 8px;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color);
        }

        /* Add hover effects for interactive elements */
        #leftPanel button, #sidebar button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        #leftPanel button:hover, #sidebar button:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px var(--accent-color);
            transform: translateY(-1px);
        }

        /* Add dividers between sections */
        .panel-divider {
            height: 1px;
            background: var(--accent-color);
            margin: 15px 0;
            box-shadow: 0 0 5px var(--accent-color);
            opacity: 0.5;
        }

        #gameArea {
            flex: 1;
            background: url('assets/images/canvas-background.png') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0;
            border: 2px solid var(--text-color);
            box-shadow: 0 0 10px rgba(0,0,255,0.5);
            position: relative;
            animation: hueRotate 10s infinite linear;
            width: 100vw;
            height: 100vh;
            border: none;
        }

        @keyframes hueRotate {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        #statsBox {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            z-index: 60;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            border: 2px solid var(--accent-color);
            background-color: #000;
            box-shadow: 0 0 10px var(--accent-color);
            image-rendering: pixelated;
            z-index: 1;
        }

        #coinPanel {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            color: var(--text-color);
            padding: 10px;
            border: 2px solid var(--border-color);
            font-family: 'Press Start 2P', cursive;
            z-index: 10;
        }

        #settingsOverlay {
            display: none;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -20%);
            background: #444;
            padding: 20px;
            border-radius: 10px;
            width: 300px;
            text-align: left;
            border: 2px solid var(--border-color);
            z-index: 50;
        }

        #gameOverScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            color: var(--text-color);
            padding: 20px;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            display: none;
            z-index: 100;
            text-align: center;
        }

        #roundTransitionOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .round-transition-content {
            text-align: center;
            font-family: var(--font-anime);
            color: var(--text-color);
            text-shadow: 0 0 10px var(--accent-color);
            animation: scaleIn 0.5s ease-out;
        }

        .round-number {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px var(--accent-color));
        }

        .round-difficulty {
            font-size: 36px;
            color: var(--highlight-color);
            margin-bottom: 30px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .countdown {
            font-size: 48px;
            color: var(--accent-color);
            animation: pulse 1s infinite;
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #backpackGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 5px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
        }

        .backpack-slot {
            background: #3c3c3c;
            color: #333;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            border: 2px solid #f16ce3;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            position: relative;
        }

            .backpack-slot:hover {
                background: #ddd;
                transform: scale(1.05);
            }

            .backpack-slot .slot-number {
                position: absolute;
                top: 2px;
                left: 2px;
                font-size: 10px;
                color: #666;
            }

        .cutscene-collage {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            padding: 30px;
            background: #1a1a1a;
            border: 2px solid #333;
            width: 95%;
            max-width: 1400px;
            height: 80vh;
            margin: auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0,0,0,0.8);
        }

        .cutscene-collage .slide {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border: none;
            transform: skew(-2deg);
            transition: transform 0.3s ease;
        }

        .cutscene-collage .slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: contrast(1.1) saturate(1.2);
            transition: filter 0.3s ease;
        }

        .cutscene-collage .slide .dialog {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.7) 70%, transparent);
            color: #fff;
            padding: 20px 15px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 16px;
            text-align: left;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .cutscene-collage .slide:hover .dialog {
            opacity: 1;
        }

        #skipCutscene {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 14px;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            z-index: 101;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #skipCutscene:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }

        #cutscene {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(5px);
        }

        .manga-page-number {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        @keyframes panelReveal {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .cutscene-collage .slide {
            animation: panelReveal 0.5s ease forwards;
            opacity: 0;
        }

        .cutscene-collage .slide:nth-child(1) { animation-delay: 0.1s; }
        .cutscene-collage .slide:nth-child(2) { animation-delay: 0.2s; }
        .cutscene-collage .slide:nth-child(3) { animation-delay: 0.3s; }
        .cutscene-collage .slide:nth-child(4) { animation-delay: 0.4s; }
        .cutscene-collage .slide:nth-child(5) { animation-delay: 0.5s; }

        .cutscene-collage .slide::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .cutscene-collage .slide:hover {
            transform: skew(-2deg) scale(1.02);
        }

        .cutscene-collage .slide:nth-child(odd) {
            transform: skew(2deg);
        }

        .cutscene-collage .slide:nth-child(odd):hover {
            transform: skew(2deg) scale(1.02);
        }

        .cutscene-collage .slide:hover img {
            filter: contrast(1.2) saturate(1.3);
        }

        .cutscene-collage .slide:nth-child(odd) .dialog {
            transform: skew(-2deg);
        }

        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: transparent;
            padding: 10px 0;
            overflow: hidden;
            z-index: 150;
        }

        .animated-banner {
            display: flex;
            width: max-content;
            animation: scrollBanner 20s linear infinite;
        }

            .animated-banner img {
                margin: 0 20px;
                max-height: 50px;
            }

        @keyframes scrollBanner {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        #walletVerifyModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        @keyframes glowPulse {
            0% {
                box-shadow: 0 0 5px var(--accent-color);
            }

            50% {
                box-shadow: 0 0 20px var(--highlight-color);
            }

            100% {
                box-shadow: 0 0 5px var(--accent-color);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite, glowPulse 2s ease-in-out infinite;
        }

        @keyframes borderHue {
            0% {
                --animated-border-color: hsl(0,100%,60%);
            }

            25% {
                --animated-border-color: hsl(120,100%,60%);
            }

            50% {
                --animated-border-color: hsl(240,100%,60%);
            }

            75% {
                --animated-border-color: hsl(300,100%,60%);
            }

            100% {
                --animated-border-color: hsl(360,100%,60%);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }

        /* Item Description Tooltip */
        .item-tooltip {
            position: absolute;
            left: 50%;
            bottom: 120%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            animation: tooltipGlow 2s infinite;
        }

        .backpack-slot:hover .item-tooltip {
            opacity: 1;
            visibility: visible;
            bottom: 130%;
        }

        @keyframes tooltipGlow {
            0% { box-shadow: 0 0 10px var(--accent-color); }
            50% { box-shadow: 0 0 20px var(--highlight-color); }
            100% { box-shadow: 0 0 10px var(--accent-color); }
        }

        .item-tooltip-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .item-tooltip-icon {
            font-size: 32px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            min-width: 50px;
            text-align: center;
        }

        .item-tooltip-details {
            flex: 1;
        }

        .item-tooltip-title {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .item-tooltip-description {
            font-family: 'Sawarabi Mincho', serif;
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.4;
        }

        .item-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--accent-color);
        }

        /* Leaderboard Styles */
        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }

        .leaderboard-entry:hover {
            transform: scale(1.02);
            background: rgba(0, 0, 0, 0.5);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 10px;
            margin-right: 8px;
        }

        .leaderboard-username {
            flex: 1;
            font-weight: bold;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        .backpack-slot {
            position: relative;
        }

        /* Achievements Styles */
        .achievements-list {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .achievement-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            text-align: center;
            animation: achievementGlow 2s infinite;
        }

        @keyframes achievementGlow {
            0% { box-shadow: 0 0 5px var(--highlight-color); }
            50% { box-shadow: 0 0 15px var(--highlight-color); }
            100% { box-shadow: 0 0 5px var(--highlight-color); }
        }

        .profile-leaderboard {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .profile-leaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .top-scores {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Item Directory Styles */
        .item-directory-entry {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .item-directory-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--highlight-color);
        }

        .item-icon {
            font-size: 24px;
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid var(--accent-color);
        }

        .item-info {
            flex: 1;
            min-width: 0; /* Prevents flex item from overflowing */
        }

        .item-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .item-description {
            font-size: 10px;
            color: var(--text-color);
            line-height: 1.3;
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .item-rarity {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
            font-family: 'Press Start 2P', cursive;
        }

        /* Rarity colors with improved visibility */
        .common {
            color: #ffffff;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        }

        .rare {
            color: #00ffff;
            text-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
        }

        .epic {
            color: #ff00ff;
            text-shadow: 0 0 4px rgba(255, 0, 255, 0.6);
        }

        .legendary {
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
        }

        /* Improved scrollbar styling */
        #itemDirectoryListHome::-webkit-scrollbar {
            width: 6px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb:hover {
            background: var(--highlight-color);
        }

        /* Add hover effect to show full description */
        .item-directory-entry:hover .item-description {
            -webkit-line-clamp: unset;
            position: relative;
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            margin-top: 2px;
        }

        /* Enhanced border animation */
        @keyframes borderHue {
            0% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
            25% { border-color: hsl(220, 100%, 70%); box-shadow: 0 0 20px hsl(220, 100%, 70%); }
            50% { border-color: hsl(120, 100%, 70%); box-shadow: 0 0 20px hsl(120, 100%, 70%); }
            75% { border-color: hsl(40, 100%, 70%); box-shadow: 0 0 20px hsl(40, 100%, 70%); }
            100% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
        }

        .hue-border {
            animation: borderHue 8s linear infinite;
            position: relative;
        }

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yumi Pop</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&family=Sawarabi+Mincho&display=swap" rel="stylesheet" />
    <!-- WalletConnect Provider Library -->
    <script src="https://unpkg.com/@walletconnect/web3-provider/dist/umd/index.min.js"></script>
    <!-- Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-database.js"></script>
    <!-- Game Scripts -->
    <script src="bubblePatterns.js"></script>
    <script type="module" src="achievements.js"></script>
    <script type="module" src="player.js"></script>
    <script>
    // Make game objects and classes available globally for bubblePatterns.js
    window.gameObjects = {
        bubbles: [],
        platforms: [],
        player: null,
        projectiles: []
    };
    window.backpackInventory = {};
    window.difficultyFactor = 1.0;
    
    // Initialize Firebase with your config
    var firebaseConfig = {
      apiKey: "AIzaSyAN-37ysgFJlncUZAVH7k79HPSqUZy4FKA",
      authDomain: "yumi-pop.firebaseapp.com",
      databaseURL: "https://yumi-pop-default-rtdb.firebaseio.com",
      projectId: "yumi-pop",
      storageBucket: "yumi-pop.firebasestorage.app",
      messagingSenderId: "328717127716",
      appId: "1:328717127716:web:9c7b5beefda761f8ae48b1",
      measurementId: "G-HHDJD3F9VY"
    };
    firebase.initializeApp(firebaseConfig);

    // Wallet Integration
    let playerWalletAddress = null;

    async function connectWallet() {
        try {
            // Check if already connected
            if (playerWalletAddress) {
                showGameMessage("Wallet already connected!");
                return;
            }

            // Check if MetaMask or other Web3 provider is available
            if (!window.ethereum) {
                showGameMessage("Please install MetaMask or another Web3 wallet!");
                window.open('https://metamask.io/download/', '_blank');
                return;
            }

            // Request account access
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });

            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            
            // Update UI
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            document.getElementById("connectWalletButton").style.display = "none";
            document.getElementById("disconnectWalletButton").style.display = "block";

            // Update Firebase record with wallet address
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }

            showGameMessage("Wallet connected successfully!");

            // Setup event listeners for wallet
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
            window.ethereum.on('disconnect', handleDisconnect);

        } catch (error) {
            console.error("Wallet connect error: ", error);
            document.getElementById("walletAddressDisplay").innerText = "Connection Failed";
            showGameMessage("Failed to connect wallet: " + error.message);
        }
    }

    async function disconnectWallet() {
        try {
            playerWalletAddress = null;

            // Update UI
            document.getElementById("walletAddressDisplay").innerText = "Not Connected";
            document.getElementById("homeProfileWallet").innerText = "Wallet: Not Connected";
            document.getElementById("connectWalletButton").style.display = "block";
            document.getElementById("disconnectWalletButton").style.display = "none";

            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: ""
                });
            }

            showGameMessage("Wallet disconnected");

            // Remove event listeners
            if (window.ethereum) {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
                window.ethereum.removeListener('disconnect', handleDisconnect);
            }
        } catch (error) {
            console.error("Error disconnecting wallet:", error);
        }
    }

    // Wallet event handlers
    function handleAccountsChanged(accounts) {
        if (accounts.length === 0) {
            disconnectWallet();
        } else if (accounts[0] !== playerWalletAddress) {
            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            
            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }
        }
    }

    function handleChainChanged() {
        // Reload the page when chain changes
        window.location.reload();
    }

    function handleDisconnect() {
        disconnectWallet();
    }

    // Add wallet button event listeners
    document.getElementById("connectWalletButton").addEventListener("click", connectWallet);
    document.getElementById("disconnectWalletButton").addEventListener("click", disconnectWallet);

    // Check if already connected on page load
    document.addEventListener('DOMContentLoaded', async () => {
        if (window.ethereum) {
            try {
                const accounts = await window.ethereum.request({ 
                    method: 'eth_accounts' 
                });
                if (accounts.length > 0) {
                    playerWalletAddress = accounts[0];
                    const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
                    document.getElementById("walletAddressDisplay").innerText = shortAddress;
                    document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
                    document.getElementById("connectWalletButton").style.display = "none";
                    document.getElementById("disconnectWalletButton").style.display = "block";
                }
            } catch (error) {
                console.error("Error checking wallet connection:", error);
            }
        }
    });

    </script>
    <style>
        /* Global CSS variables for neon pink/green vibe */
        :root {
            --bg-color: #101010;
            --panel-bg: #2f2f2f;
            --border-color: #e7e7e7;
            --accent-color: #46fbe3;
            --hover-color: #46fbe3;
            --text-color: #ffffff;
            --highlight-color: #ff5fd4;
            --font-anime: 'Bangers', 'Press Start 2P', 'Sawarabi Mincho', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Sawarabi Mincho', serif;
            font-size: 12px;
            overflow: hidden;
            image-rendering: auto;
        }

        header, main, aside {
            display: block;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: buttonHue 5s linear infinite;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            border-color: var(--highlight-color);
        }

        button:active {
            transform: translateY(1px);
        }

        @keyframes buttonHue {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Hue border animation for key UI elements */
        #homeScreenContainer, #walletAndStartSection, #profilePreviewSection, #homeLeaderboard, #itemDirectorySection {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }
        /* Home Screen */
        #startScreen, #cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background-image: url('assets/images/custom-background.png');
            background-repeat: no-repeat;
            background-position: center;
            background-size: cover;
            border: 4px solid var(--border-color);
            box-shadow: 0 0 0 8px #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: border 0.5s ease;
            animation: hueRotate 10s infinite linear;
        }

        #homeScreenContainer {
            width: 90%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            margin: 0 auto;
            height: calc(100vh - 100px);
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        #mainContent {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #itemDirectorySection {
            flex: 0 0 auto;
            margin: 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        #homeLeaderboard {
            flex: 0 0 auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }

        #homeLeaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--accent-color);
        }

        #homeLeaderboardList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .leaderboard-entry {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.8);
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 14px;
            min-width: 30px;
        }

        .leaderboard-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboard-player img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid var(--accent-color);
        }

        .leaderboard-username {
            color: var(--text-color);
            font-size: 14px;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
        }

        #homeInputSection label, #walletAndStartSection label {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
        }

        #homeInputSection input, #walletAndStartSection input, #homeInputSection select {
            padding: 5px;
            font-size: 12px;
            border: 2px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: 5px;
            margin-top: 5px;
        }

        .info-box {
            width: 100%;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #walletAndStartSection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        #profilePreviewSection .profile {
            display: flex;
            gap: 10px;
            align-items: center;
        }

            #profilePreviewSection .profile img {
                width: 50px;
                height: 50px;
                border: 2px solid var(--accent-color);
                border-radius: 50%;
            }

        #profilePreviewSection .profile-info p {
            margin: 2px 0;
        }

        #leaderboardAndItemsWrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }

        #homeLeaderboard, #itemDirectorySection {
            flex: 1;
            min-width: 45%;
        }

        #homeLeaderboard {
            width: 100%;
        }

            #homeLeaderboard h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        #itemDirectorySection {
            width: 100%;
            margin-top: 20px;
        }

            #itemDirectorySection h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #itemDirectoryListHome {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Main Game UI */
        #mainContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            display: none;
            flex-direction: row;
            gap: 0;
            padding: 10px;
        }

            #mainContainer.fullScreen {
                padding: 0;
                flex-direction: column;
            }

                #mainContainer.fullScreen #leftPanel,
                #mainContainer.fullScreen #sidebar,
                #coinPanel {
                    display: none;
                }

        #topButtons {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #topButtons {
            display: flex;
        }

        #topButtons button {
            padding: 8px 15px;
            font-size: 12px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #topButtons button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
        }

        #keyMapOverlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            font-size: 12px;
            color: var(--text-color);
            z-index: 100;
            transition: all 0.3s ease;
            max-height: 40px;
            overflow: hidden;
            cursor: pointer;
        }

        #keyMapOverlay:hover {
            max-height: 200px;
        }

        #keyMapOverlay h4 {
            color: var(--accent-color);
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            min-width: 20px;
            text-align: center;
        }

        #statsBox {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--highlight-color);
            z-index: 100;
            text-align: center;
            transition: all 0.3s ease;
        }

        #backpackHudFullScreen {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
        }

        /* Hover effects for UI elements */
        #topButtons:hover,
        #keyMapOverlay:hover,
        #backpackHudFullScreen:hover,
        #statsBox:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }

        #statsBox:hover {
            transform: translateX(-50%) scale(1.05);
        }

        /* Collapsed key map state */
        #keyMapOverlay::after {
            content: '⌨️ Controls';
            display: block;
            text-align: center;
            padding: 5px;
            font-size: 12px;
            color: var(--accent-color);
        }

        #keyMapOverlay:hover::after {
            display: none;
        }

        /* Game canvas adjustments */
        #mainContainer.fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            border: none;
        }

        /* Ensure UI elements don't interfere with gameplay */
        #gameArea {
            position: relative;
            overflow: hidden;
        }

        /* Mobile-friendly adjustments */
        @media (max-width: 768px) {
            #topButtons,
            #keyMapOverlay,
            #backpackHudFullScreen,
            #statsBox {
                transform: scale(0.8);
                padding: 8px;
            }

            #topButtons {
                right: 10px;
            }

            #keyMapOverlay {
                left: 10px;
            }

            #backpackHudFullScreen {
                bottom: 10px;
            }
        }

        #mainContainer.fullScreen #topButtons button {
            padding: 8px 12px;
            font-size: 10px;
            min-width: 80px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #keyMapOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 10px;
            text-align: left;
            color: var(--text-color);
        }

        #keyMapOverlay h4 {
            margin: 0 0 4px 0;
            font-size: 10px;
        }

        #keyMapOverlay p {
            margin: 2px 0;
            font-size: 9px;
        }

        #backpackHudFullScreen {
            display: none;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            align-items: center;
            z-index: 50;
        }

        #leftPanel, #sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-color);
            box-shadow: 0 0 15px var(--accent-color);
            position: relative;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
        }

        #sidebar {
            text-align: center;
        }

        #sidebar img {
            display: block;
            margin: 15px auto;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .portraitContainer {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid var(--accent-color);
        }

        .portraitContainer img {
            width: 180px;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 4px;
        }

        #keyMap {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-color);
            font-size: 10px;
            text-align: left;
            color: var(--highlight-color);
        }

        #keyMap h4 {
            margin: 0 0 8px;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color);
        }

        /* Add hover effects for interactive elements */
        #leftPanel button, #sidebar button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        #leftPanel button:hover, #sidebar button:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px var(--accent-color);
            transform: translateY(-1px);
        }

        /* Add dividers between sections */
        .panel-divider {
            height: 1px;
            background: var(--accent-color);
            margin: 15px 0;
            box-shadow: 0 0 5px var(--accent-color);
            opacity: 0.5;
        }

        #gameArea {
            flex: 1;
            background: url('assets/images/canvas-background.png') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0;
            border: 2px solid var(--text-color);
            box-shadow: 0 0 10px rgba(0,0,255,0.5);
            position: relative;
            animation: hueRotate 10s infinite linear;
            width: 100vw;
            height: 100vh;
            border: none;
        }

        @keyframes hueRotate {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        #statsBox {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            z-index: 60;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            border: 2px solid var(--accent-color);
            background-color: #000;
            box-shadow: 0 0 10px var(--accent-color);
            image-rendering: pixelated;
            z-index: 1;
        }

        #coinPanel {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            color: var(--text-color);
            padding: 10px;
            border: 2px solid var(--border-color);
            font-family: 'Press Start 2P', cursive;
            z-index: 10;
        }

        #settingsOverlay {
            display: none;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -20%);
            background: #444;
            padding: 20px;
            border-radius: 10px;
            width: 300px;
            text-align: left;
            border: 2px solid var(--border-color);
            z-index: 50;
        }

        #gameOverScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            color: var(--text-color);
            padding: 20px;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            display: none;
            z-index: 100;
            text-align: center;
        }

        #roundTransitionOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .round-transition-content {
            text-align: center;
            font-family: var(--font-anime);
            color: var(--text-color);
            text-shadow: 0 0 10px var(--accent-color);
            animation: scaleIn 0.5s ease-out;
        }

        .round-number {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px var(--accent-color));
        }

        .round-difficulty {
            font-size: 36px;
            color: var(--highlight-color);
            margin-bottom: 30px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .countdown {
            font-size: 48px;
            color: var(--accent-color);
            animation: pulse 1s infinite;
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #backpackGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 5px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
        }

        .backpack-slot {
            background: #3c3c3c;
            color: #333;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            border: 2px solid #f16ce3;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            position: relative;
        }

            .backpack-slot:hover {
                background: #ddd;
                transform: scale(1.05);
            }

            .backpack-slot .slot-number {
                position: absolute;
                top: 2px;
                left: 2px;
                font-size: 10px;
                color: #666;
            }

        .cutscene-collage {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            padding: 30px;
            background: #1a1a1a;
            border: 2px solid #333;
            width: 95%;
            max-width: 1400px;
            height: 80vh;
            margin: auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0,0,0,0.8);
        }

        .cutscene-collage .slide {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border: none;
            transform: skew(-2deg);
            transition: transform 0.3s ease;
        }

        .cutscene-collage .slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: contrast(1.1) saturate(1.2);
            transition: filter 0.3s ease;
        }

        .cutscene-collage .slide .dialog {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.7) 70%, transparent);
            color: #fff;
            padding: 20px 15px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 16px;
            text-align: left;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .cutscene-collage .slide:hover .dialog {
            opacity: 1;
        }

        #skipCutscene {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 14px;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            z-index: 101;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #skipCutscene:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }

        #cutscene {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(5px);
        }

        .manga-page-number {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'Sawarabi Mincho', serif;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        @keyframes panelReveal {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .cutscene-collage .slide {
            animation: panelReveal 0.5s ease forwards;
            opacity: 0;
        }

        .cutscene-collage .slide:nth-child(1) { animation-delay: 0.1s; }
        .cutscene-collage .slide:nth-child(2) { animation-delay: 0.2s; }
        .cutscene-collage .slide:nth-child(3) { animation-delay: 0.3s; }
        .cutscene-collage .slide:nth-child(4) { animation-delay: 0.4s; }
        .cutscene-collage .slide:nth-child(5) { animation-delay: 0.5s; }

        .cutscene-collage .slide::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .cutscene-collage .slide:hover {
            transform: skew(-2deg) scale(1.02);
        }

        .cutscene-collage .slide:nth-child(odd) {
            transform: skew(2deg);
        }

        .cutscene-collage .slide:nth-child(odd):hover {
            transform: skew(2deg) scale(1.02);
        }

        .cutscene-collage .slide:hover img {
            filter: contrast(1.2) saturate(1.3);
        }

        .cutscene-collage .slide:nth-child(odd) .dialog {
            transform: skew(-2deg);
        }

        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: transparent;
            padding: 10px 0;
            overflow: hidden;
            z-index: 150;
        }

        .animated-banner {
            display: flex;
            width: max-content;
            animation: scrollBanner 20s linear infinite;
        }

            .animated-banner img {
                margin: 0 20px;
                max-height: 50px;
            }

        @keyframes scrollBanner {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        #walletVerifyModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        @keyframes glowPulse {
            0% {
                box-shadow: 0 0 5px var(--accent-color);
            }

            50% {
                box-shadow: 0 0 20px var(--highlight-color);
            }

            100% {
                box-shadow: 0 0 5px var(--accent-color);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite, glowPulse 2s ease-in-out infinite;
        }

        @keyframes borderHue {
            0% {
                --animated-border-color: hsl(0,100%,60%);
            }

            25% {
                --animated-border-color: hsl(120,100%,60%);
            }

            50% {
                --animated-border-color: hsl(240,100%,60%);
            }

            75% {
                --animated-border-color: hsl(300,100%,60%);
            }

            100% {
                --animated-border-color: hsl(360,100%,60%);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }

        /* Item Description Tooltip */
        .item-tooltip {
            position: absolute;
            left: 50%;
            bottom: 120%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            animation: tooltipGlow 2s infinite;
        }

        .backpack-slot:hover .item-tooltip {
            opacity: 1;
            visibility: visible;
            bottom: 130%;
        }

        @keyframes tooltipGlow {
            0% { box-shadow: 0 0 10px var(--accent-color); }
            50% { box-shadow: 0 0 20px var(--highlight-color); }
            100% { box-shadow: 0 0 10px var(--accent-color); }
        }

        .item-tooltip-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .item-tooltip-icon {
            font-size: 32px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            min-width: 50px;
            text-align: center;
        }

        .item-tooltip-details {
            flex: 1;
        }

        .item-tooltip-title {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .item-tooltip-description {
            font-family: 'Sawarabi Mincho', serif;
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.4;
        }

        .item-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--accent-color);
        }

        /* Leaderboard Styles */
        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }

        .leaderboard-entry:hover {
            transform: scale(1.02);
            background: rgba(0, 0, 0, 0.5);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 10px;
            margin-right: 8px;
        }

        .leaderboard-username {
            flex: 1;
            font-weight: bold;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        .backpack-slot {
            position: relative;
        }

        /* Achievements Styles */
        .achievements-list {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .achievement-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            text-align: center;
            animation: achievementGlow 2s infinite;
        }

        @keyframes achievementGlow {
            0% { box-shadow: 0 0 5px var(--highlight-color); }
            50% { box-shadow: 0 0 15px var(--highlight-color); }
            100% { box-shadow: 0 0 5px var(--highlight-color); }
        }

        .profile-leaderboard {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .profile-leaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .top-scores {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Item Directory Styles */
        .item-directory-entry {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .item-directory-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--highlight-color);
        }

        .item-icon {
            font-size: 24px;
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid var(--accent-color);
        }

        .item-info {
            flex: 1;
            min-width: 0; /* Prevents flex item from overflowing */
        }

        .item-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .item-description {
            font-size: 10px;
            color: var(--text-color);
            line-height: 1.3;
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .item-rarity {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
            font-family: 'Press Start 2P', cursive;
        }

        /* Rarity colors with improved visibility */
        .common {
            color: #ffffff;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        }

        .rare {
            color: #00ffff;
            text-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
        }

        .epic {
            color: #ff00ff;
            text-shadow: 0 0 4px rgba(255, 0, 255, 0.6);
        }

        .legendary {
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
        }

        /* Improved scrollbar styling */
        #itemDirectoryListHome::-webkit-scrollbar {
            width: 6px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb:hover {
            background: var(--highlight-color);
        }

        /* Add hover effect to show full description */
        .item-directory-entry:hover .item-description {
            -webkit-line-clamp: unset;
            position: relative;
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            margin-top: 2px;
        }

        /* Enhanced border animation */
        @keyframes borderHue {
            0% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
            25% { border-color: hsl(220, 100%, 70%); box-shadow: 0 0 20px hsl(220, 100%, 70%); }
            50% { border-color: hsl(120, 100%, 70%); box-shadow: 0 0 20px hsl(120, 100%, 70%); }
            75% { border-color: hsl(40, 100%, 70%); box-shadow: 0 0 20px hsl(40, 100%, 70%); }
            100% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
        }

        .hue-border {
            animation: borderHue 8s linear infinite;
            position: relative;
        }

        .hue-border::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: inherit;
            background: linear-gradient(45deg, 
                hsla(320, 100%, 70%, 0.5),
                hsla(220, 100%, 70%, 0.5),
                hsla(120, 100%, 70%, 0.5),
                hsla(40, 100%, 70%, 0.5)
            );
            filter: blur(8px);
            opacity: 0.5;
            z-index: -1;
            animation: borderGlow 8s linear infinite;
        }

        @keyframes borderGlow {
            0% { filter: blur(8px) hue-rotate(0deg); }
            100% { filter: blur(8px) hue-rotate(360deg); }
        }

        /* Enhanced title design */
        #homeScreenContainer h1 {
            font-family: 'Bangers', cursive;
            font-size: 72px;
            text-align: center;
            margin: 20px 0;
            color: transparent;
            background: linear-gradient(
                45deg,
                #ff69b4,
                #ff1493,
                #ff69b4,
                #ff1493
            );
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            text-shadow: 
                3px 3px 0 rgba(255,20,147,0.2),
                -3px -3px 0 rgba(255,105,180,0.2),
                6px 6px 10px rgba(0,0,0,0.3);
            position: relative;
            animation: titleGradient 4s ease infinite;
            letter-spacing: 2px;
        }

        @keyframes titleGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Add wallet connection styles */
        .wallet-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: var(--panel-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        #connectWalletButton,
        #disconnectWalletButton {
            padding: 8px 16px;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            color: var(--text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-anime);
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #connectWalletButton:hover,
        #disconnectWalletButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }

        #disconnectWalletButton {
            background: linear-gradient(45deg, #ff4444, #ff0000);
        }

        #walletAddressDisplay {
            font-family: monospace;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            min-width: 140px;
            text-align: center;
        }

        /* Web3Modal customization */
        :root {
            --w3m-accent-color: var(--accent-color);
            --w3m-background-color: var(--panel-bg);
            --w3m-text-color: var(--text-color);
            --w3m-border-radius: 8px;
        }

        #homeScreenContainer h1::before {
            content: 'ユミポップ';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-family: 'Sawarabi Mincho', serif;
            color: #ff69b4;
            opacity: 0.8;
            text-shadow: none;
            letter-spacing: 4px;
        }

        #homeScreenContainer h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 2px;
            background: linear-gradient(
                90deg,
                transparent,
                #ff69b4,
                #ff1493,
                #ff69b4,
                transparent
            );
        }

        /* Enhanced panel transitions */
        .info-box {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .info-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: left 0.5s ease;
        }

        .info-box:hover::before {
            left: 100%;
        }

        .info-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        /* Enhanced background effects */
        #startScreen {
            position: relative;
            overflow: hidden;
        }

        #startScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, 
                    rgba(255,105,180,0.1),
                    rgba(255,20,147,0.1)
                ),
                url('assets/images/custom-background.png');
            background-size: cover;
            filter: brightness(0.9) contrast(1.1);
            z-index: -1;
            animation: backgroundPulse 10s ease infinite;
        }

        @keyframes backgroundPulse {
            0% { filter: brightness(0.9) contrast(1.1) hue-rotate(0deg); }
            50% { filter: brightness(1) contrast(1.2) hue-rotate(15deg); }
            100% { filter: brightness(0.9) contrast(1.1) hue-rotate(0deg); }
        }

        /* Add sparkle effects to title */
        @keyframes sparkle {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1) rotate(180deg); opacity: 1; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .sparkle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #fff, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkle 2s linear infinite;
        }

        /* Add this JavaScript to create sparkles */
        function createSparkles() {
            const title = document.querySelector('#homeScreenContainer h1');
            const sparkleCount = 3;
            
            setInterval(() => {
                for (let i = 0; i < sparkleCount; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    const x = Math.random() * title.offsetWidth;
                    const y = Math.random() * title.offsetHeight;
                    
                    sparkle.style.left = x + 'px';
                    sparkle.style.top = y + 'px';
                    sparkle.style.animationDelay = Math.random() * 2 + 's';
                    
                    title.appendChild(sparkle);
                    
                    setTimeout(() => sparkle.remove(), 2000);
                }
            }, 500);
        }

        /* Mobile Optimization Styles */
        @media (max-width: 768px) {
            #leftPanel, #sidebar {
                display: none;
            }
            
            #mainContainer {
                padding: 0;
                width: 100vw;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            
            #gameCanvas {
                touch-action: none;
                width: 100%;
                height: 100%;
            }
            
            #backpackHudFullScreen {
                transform: scale(0.8);
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%) scale(0.8);
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px;
                z-index: 100;
            }
            
            #topButtons {
                transform: scale(0.8);
                top: 10px;
                left: 50%;
                transform: translateX(-50%) scale(0.8);
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px;
                z-index: 100;
            }
            
            .backpack-slot {
                padding: 5px;
                font-size: 12px;
                min-width: 40px;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            #statsBox {
                font-size: 12px;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                top: 10px;
                z-index: 100;
            }
            
            #coinPanel {
                transform: scale(0.8);
                bottom: 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px 10px;
                z-index: 100;
            }

            #gameMessage {
                font-size: 14px;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                z-index: 100;
            }

            /* Hide round transition overlay on mobile */
            #roundTransitionOverlay {
                display: none !important;
            }
        }

        .mobile-mode {
            /* Mobile-specific styles */
            --button-size: 60px;
            --button-margin: 10px;
        }

        .mobile-mode #gameArea {
            touch-action: none;
        }

        .mobile-mode .control-button {
            position: fixed;
            width: var(--button-size);
            height: var(--button-size);
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            color: var(--text-color);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            touch-action: none;
        }

        .mobile-mode .move-left {
            left: var(--button-margin);
            bottom: var(--button-margin);
        }

        .mobile-mode .move-right {
            left: calc(var(--button-size) + var(--button-margin) * 2);
            bottom: var(--button-margin);
        }

        .mobile-mode .jump-button {
            right: calc(var(--button-size) + var(--button-margin) * 2);
            bottom: var(--button-margin);
        }

        .mobile-mode .shoot-button {
            right: var(--button-margin);
            bottom: var(--button-margin);
        }

        .mobile-mode .backpack-button {
            right: var(--button-margin);
            bottom: calc(var(--button-size) + var(--button-margin) * 2);
        }

        @media (max-width: 768px) {
            .mobile-mode .control-button {
                --button-size: 50px;
                --button-margin: 8px;
            }
        }

        #gameMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-color);
            padding: 15px 30px;
            border-radius: 8px;
            font-family: var(--font-anime);
            font-size: 24px;
            text-align: center;
            z-index: 100;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: messageFloat 0.5s ease-out;
        }

        #gameMessage.show {
            opacity: 1;
        }

        @keyframes messageFloat {
            from {
                transform: translate(-50%, 20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        /* Base Layout Styles */
        #mainContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            display: none;
            flex-direction: row;
            gap: 0;
            padding: 10px;
        }

/* Basic View Styles */
.basic-view #leftPanel, 
.basic-view #sidebar {
  display: none;
}
.basic-view .info-box {
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  border: 2px solid var(--accent-color);
  margin-bottom: 15px;
  padding: 15px;
  border-radius: 10px;
}
.basic-view #gameArea {
  flex: 1;
  margin: 0 10px;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 10px;
  border: 2px solid var(--accent-color);
  box-shadow: 0 0 20px rgba(70, 251, 227, 0.2);
}
.basic-view #gameCanvas {
  border: 2px solid var(--accent-color);
  box-shadow: 0 0 15px var(--accent-color);
  border-radius: 8px;
  margin: 10px;
}
.basic-view #topButtons {
  position: relative;
  margin-top: 10px;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  padding: 12px;
  border: 2px solid var(--accent-color);
  border-radius: 12px;
}
/* Hide backpack HUD in basic view */
.basic-view #backpackHudFullScreen {
  display: none;
}

        /* Full Screen View Styles */
        .fullScreen #leftPanel,
        .fullScreen #sidebar {
            display: none;
        }

        .fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            border: none;
        }

        .fullScreen #topButtons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            min-width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .fullScreen #topButtons::-webkit-scrollbar {
            width: 6px;
        }

        .fullScreen #topButtons::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        .fullScreen #topButtons::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        .fullScreen #backpackHudFullScreen {
            display: none;
        }

        .fullScreen #topButtons .section-header {
            color: var(--accent-color);
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            margin: 12px 0 8px 0;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .fullScreen #topButtons .section-content {
            margin-bottom: 15px;
        }

        .fullScreen #topButtons .backpack-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            margin: 10px 0;
        }

        .fullScreen #topButtons .backpack-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--accent-color);
            border-radius: 6px;
            padding: 8px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .fullScreen #topButtons .backpack-slot:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
            border-color: var(--highlight-color);
        }

        .fullScreen #topButtons .backpack-slot .slot-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: var(--accent-color);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .fullScreen #topButtons .backpack-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: var(--highlight-color);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .fullScreen #topButtons .item-tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--accent-color);
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 101;
            width: max-content;
            max-width: 200px;
        }

        .fullScreen #topButtons .backpack-slot:hover .item-tooltip {
            opacity: 1;
        }

        .fullScreen #topButtons.minimized {
            min-width: unset;
            width: auto;
        }

        .fullScreen #topButtons.minimized .section-content,
        .fullScreen #topButtons.minimized .divider {
            display: none;
        }

        /* Update the minimize button style */
        .fullScreen #topButtons .minimize-button {
            background: none;
            border: none;
            color: var(--accent-color);
            padding: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .fullScreen #topButtons .minimize-button:hover {
            color: var(--highlight-color);
        }

        /* Add section dividers */
        .fullScreen #topButtons .divider {
            height: 1px;
            background: var(--accent-color);
            margin: 10px 0;
            opacity: 0.5;
        }

        .fullScreen #topButtons button {
            padding: 8px 15px;
            font-size: 12px;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fullScreen #topButtons button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.02);
        }

        .fullScreen #topButtons .controls-section {
            margin-top: 10px;
        }

        .fullScreen #topButtons .controls-header {
            color: var(--accent-color);
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .fullScreen #topButtons .control-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            color: var(--text-color);
            font-size: 11px;
        }

        .fullScreen #topButtons .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            min-width: 20px;
            text-align: center;
        }

        .fullScreen #topButtons .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .fullScreen #topButtons .minimize-button {
            background: none;
            border: none;
            color: var(--accent-color);
            padding: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .fullScreen #topButtons.minimized {
            width: auto;
            min-width: unset;
        }

        .fullScreen #topButtons.minimized .button-group,
        .fullScreen #topButtons.minimized .divider,
        .fullScreen #topButtons.minimized .controls-section {
            display: none;
        }

        .fullScreen #topButtons.minimized .minimize-button {
            transform: rotate(180deg);
        }

        /* Remove the separate key map overlay since it's now integrated */
        .fullScreen #keyMapOverlay {
            display: none;
        }

        /* Ensure the game canvas takes full space */
        .fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            border: none;
        }

        /* Mobile View Styles */
        @media (max-width: 768px) {
            .mobile-mode #mainContainer {
                padding: 0;
            }

            .mobile-mode #gameCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            .mobile-mode #topButtons {
                transform: scale(0.8);
                right: 5px;
                top: 5px;
                padding: 8px;
            }

            .mobile-mode #keyMapOverlay {
                transform: scale(0.8);
                left: 5px;
                top: 5px;
                padding: 8px;
            }

            .mobile-mode #statsBox {
                transform: translateX(-50%) scale(0.8);
                top: 5px;
                padding: 5px 10px;
                font-size: 10px;
            }

            .mobile-mode #backpackHudFullScreen {
                transform: translateX(-50%) scale(0.8);
                bottom: 5px;
                padding: 5px;
            }

            .mobile-mode .control-button {
                --button-size: 50px;
                position: fixed;
                width: var(--button-size);
                height: var(--button-size);
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid var(--accent-color);
                border-radius: 50%;
                color: var(--text-color);
                font-size: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                touch-action: none;
            }

            .mobile-mode .move-left {
                left: 10px;
                bottom: 10px;
            }

            .mobile-mode .move-right {
                left: 70px;
                bottom: 10px;
            }

            .mobile-mode .jump-button {
                right: 70px;
                bottom: 10px;
            }

            .mobile-mode .shoot-button {
                right: 10px;
                bottom: 10px;
            }

            .mobile-mode .backpack-button {
                right: 10px;
                bottom: 70px;
            }
        }

        /* iOS Specific Adjustments */
        @supports (-webkit-touch-callout: none) {
            .mobile-mode #mainContainer {
                height: -webkit-fill-available;
            }

            .mobile-mode .control-button {
                padding: env(safe-area-inset-bottom);
            }

            .mobile-mode #backpackHudFullScreen {
                bottom: calc(env(safe-area-inset-bottom) + 5px);
            }
        }

        /* Shared UI Element Styles */
        .ui-element {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .ui-element:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }

        /* Button Styles */
        .game-button {
            padding: 8px 15px;
            font-size: 12px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .game-button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
        }

        /* Add view mode detection and switching logic */
        <script>
  function updateViewMode() {
    const mainContainer = document.getElementById('mainContainer');
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const isTablet = window.innerWidth <= 1024 && window.innerWidth > 768;
    const isFullScreen = document.fullscreenElement !== null;
    
    mainContainer.classList.remove('basic-view', 'fullScreen', 'mobile-mode', 'tablet-mode');
    
    if (isMobile || isTablet) {
      mainContainer.classList.add(isMobile ? 'mobile-mode' : 'tablet-mode');
      enableTouchControls();
      adjustForMobileUI();
    } else if (isFullScreen) {
      mainContainer.classList.add('fullScreen');
      disableTouchControls();
    } else {
      mainContainer.classList.add('basic-view');
      disableTouchControls();
    }
    
    adjustCanvasSize();
    updateBackpackUI();
    updateMobileOrientation();
  }

  function updateMobileOrientation() {
    const isLandscape = window.innerWidth > window.innerHeight;
    document.body.classList.toggle('landscape', isLandscape);
    document.body.classList.toggle('portrait', !isLandscape);
    
    if (window.innerWidth <= 768) {
      const message = isLandscape ? '' : 'Please rotate your device to landscape mode for better gameplay';
      const orientationMsg = document.getElementById('orientationMessage') || createOrientationMessage();
      orientationMsg.textContent = message;
      orientationMsg.style.display = isLandscape ? 'none' : 'block';
    }
  }

  function createOrientationMessage() {
    const msg = document.createElement('div');
    msg.id = 'orientationMessage';
    msg.className = 'game-message';
    document.body.appendChild(msg);
    return msg;
  }

  function adjustForMobileUI() {
    const gameCanvas = document.getElementById('gameCanvas');
    if (!gameCanvas) return;

    // Prevent default touch behaviors
    gameCanvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
    gameCanvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    
    // Adjust UI scaling based on device
    const scaleFactor = Math.min(window.innerWidth / 1000, window.innerHeight / 600);
    document.documentElement.style.setProperty('--ui-scale', scaleFactor.toString());
    
    // Enable touch controls
    setupTouchControls();
  }

  function enableTouchControls() {
    const touchControls = document.querySelectorAll('.control-button');
    touchControls.forEach(button => {
      button.style.display = 'flex';
    });
  }

  function disableTouchControls() {
    const touchControls = document.querySelectorAll('.control-button');
    touchControls.forEach(button => {
      button.style.display = 'none';
    });
  }

  // Event Listeners for Mobile Detection
  window.addEventListener('resize', updateViewMode);
  window.addEventListener('orientationchange', updateViewMode);
  document.addEventListener('fullscreenchange', updateViewMode);
  document.addEventListener('DOMContentLoaded', updateViewMode);
</script>
    <style>
        /* Global CSS variables for neon pink/green vibe */
        :root {
            --bg-color: #101010;
            --panel-bg: #2f2f2f;
            --border-color: #e7e7e7;
            --accent-color: #46fbe3;
            --hover-color: #46fbe3;
            --text-color: #ffffff;
            --highlight-color: #ff5fd4;
            --font-anime: 'Bangers', 'Press Start 2P', 'Sawarabi Mincho', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Sawarabi Mincho', serif;
            font-size: 12px;
            overflow: hidden;
            image-rendering: auto;
        }

        header, main, aside {
            display: block;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: buttonHue 5s linear infinite;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            border-color: var(--highlight-color);
        }

        button:active {
            transform: translateY(1px);
        }

        @keyframes buttonHue {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Hue border animation for key UI elements */
        #homeScreenContainer, #walletAndStartSection, #profilePreviewSection, #homeLeaderboard, #itemDirectorySection {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }
        /* Home Screen */
        #startScreen, #cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background-image: url('assets/images/custom-background.png');
            background-repeat: no-repeat;
            background-position: center;
            background-size: cover;
            border: 4px solid var(--border-color);
            box-shadow: 0 0 0 8px #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: border 0.5s ease;
            animation: hueRotate 10s infinite linear;
        }

        #homeScreenContainer {
            width: 90%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            margin: 0 auto;
            height: calc(100vh - 100px);
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        #mainContent {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #itemDirectorySection {
            flex: 0 0 auto;
            margin: 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        #homeLeaderboard {
            flex: 0 0 auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }

        #homeLeaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--accent-color);
        }

        #homeLeaderboardList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .leaderboard-entry {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.8);
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 14px;
            min-width: 30px;
        }

        .leaderboard-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboard-player img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid var(--accent-color);
        }

        .leaderboard-username {
            color: var(--text-color);
            font-size: 14px;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
        }

        #homeInputSection label, #walletAndStartSection label {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
        }

        #homeInputSection input, #walletAndStartSection input, #homeInputSection select {
            padding: 5px;
            font-size: 12px;
            border: 2px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: 5px;
            margin-top: 5px;
        }

        .info-box {
            width: 100%;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #walletAndStartSection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        #profilePreviewSection .profile {
            display: flex;
            gap: 10px;
            align-items: center;
        }

            #profilePreviewSection .profile img {
                width: 50px;
                height: 50px;
                border: 2px solid var(--accent-color);
                border-radius: 50%;
            }

        #profilePreviewSection .profile-info p {
            margin: 2px 0;
        }

        #leaderboardAndItemsWrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }

        #homeLeaderboard, #itemDirectorySection {
            flex: 1;
            min-width: 45%;
        }

        #homeLeaderboard {
            width: 100%;
        }

            #homeLeaderboard h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        #itemDirectorySection {
            width: 100%;
            margin-top: 20px;
        }

            #itemDirectorySection h3 {
                font-family: 'Press Start 2P', cursive;
                color: var(--accent-color);
                margin-bottom: 5px;
            }

        #itemDirectoryListHome {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Main Game UI */
        #mainContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            display: none;
            flex-direction: row;
            gap: 0;
            padding: 10px;
        }

            #mainContainer.fullScreen {
                padding: 0;
                flex-direction: column;
            }

                #mainContainer.fullScreen #leftPanel,
                #mainContainer.fullScreen #sidebar,
                #coinPanel {
                    display: none;
                }

        #topButtons {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #topButtons {
            display: flex;
        }

        #topButtons button {
            padding: 8px 15px;
            font-size: 12px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #topButtons button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
        }

        #keyMapOverlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            font-size: 12px;
            color: var(--text-color);
            z-index: 100;
            transition: all 0.3s ease;
            max-height: 40px;
            overflow: hidden;
            cursor: pointer;
        }

        #keyMapOverlay:hover {
            max-height: 200px;
        }

        #keyMapOverlay h4 {
            color: var(--accent-color);
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            min-width: 20px;
            text-align: center;
        }

        #statsBox {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--highlight-color);
            z-index: 100;
            text-align: center;
            transition: all 0.3s ease;
        }

        #backpackHudFullScreen {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
        }

        /* Hover effects for UI elements */
        #topButtons:hover,
        #keyMapOverlay:hover,
        #backpackHudFullScreen:hover,
        #statsBox:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }

        #statsBox:hover {
            transform: translateX(-50%) scale(1.05);
        }

        /* Collapsed key map state */
        #keyMapOverlay::after {
            content: '⌨️ Controls';
            display: block;
            text-align: center;
            padding: 5px;
            font-size: 12px;
            color: var(--accent-color);
        }

        #keyMapOverlay:hover::after {
            display: none;
        }

        /* Game canvas adjustments */
        #mainContainer.fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            border: none;
        }

        /* Ensure UI elements don't interfere with gameplay */
        #gameArea {
            position: relative;
            overflow: hidden;
        }

        /* Mobile-friendly adjustments */
        @media (max-width: 768px) {
            #topButtons,
            #keyMapOverlay,
            #backpackHudFullScreen,
            #statsBox {
                transform: scale(0.8);
                padding: 8px;
            }

            #topButtons {
                right: 10px;
            }

            #keyMapOverlay {
                left: 10px;
            }

            #backpackHudFullScreen {
                bottom: 10px;
            }
        }

        #mainContainer.fullScreen #topButtons button {
            padding: 8px 12px;
            font-size: 10px;
            min-width: 80px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #keyMapOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 10px;
            text-align: left;
            color: var(--text-color);
        }

        #keyMapOverlay h4 {
            margin: 0 0 4px 0;
            font-size: 10px;
        }

        #keyMapOverlay p {
            margin: 2px 0;
            font-size: 9px;
        }

        #backpackHudFullScreen {
            display: none;
        }

        #mainContainer.fullScreen #backpackHudFullScreen {
            display: flex;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            align-items: center;
            z-index: 50;
        }

        #leftPanel, #sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-color);
            box-shadow: 0 0 15px var(--accent-color);
            position: relative;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
        }

        #sidebar {
            text-align: center;
        }

        #sidebar img {
            display: block;
            margin: 15px auto;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .portraitContainer {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid var(--accent-color);
        }

        .portraitContainer img {
            width: 180px;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 4px;
        }

        #keyMap {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-color);
            font-size: 10px;
            text-align: left;
            color: var(--highlight-color);
        }

        #keyMap h4 {
            margin: 0 0 8px;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color);
        }

        /* Add hover effects for interactive elements */
        #leftPanel button, #sidebar button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        #leftPanel button:hover, #sidebar button:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px var(--accent-color);
            transform: translateY(-1px);
        }

        /* Add dividers between sections */
        .panel-divider {
            height: 1px;
            background: var(--accent-color);
            margin: 15px 0;
            box-shadow: 0 0 5px var(--accent-color);
            opacity: 0.5;
        }

        #gameArea {
            flex: 1;
            background: url('assets/images/canvas-background.png') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0;
            border: 2px solid var(--text-color);
            box-shadow: 0 0 10px rgba(0,0,255,0.5);
            position: relative;
            animation: hueRotate 10s infinite linear;
            width: 100vw;
            height: 100vh;
            border: none;
        }

        @keyframes hueRotate {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        #statsBox {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            z-index: 60;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            border: 2px solid var(--accent-color);
            background-color: #000;
            box-shadow: 0 0 10px var(--accent-color);
            image-rendering: pixelated;
            z-index: 1;
        }

        #coinPanel {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            color: var(--text-color);
            padding: 10px;
            border: 2px solid var(--border-color);
            font-family: 'Press Start 2P', cursive;
            z-index: 10;
        }

        #settingsOverlay {
            display: none;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -20%);
            background: #444;
            padding: 20px;
            border-radius: 10px;
            width: 300px;
            text-align: left;
            border: 2px solid var(--border-color);
            z-index: 50;
        }

        #gameOverScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            color: var(--text-color);
            padding: 20px;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            display: none;
            z-index: 100;
            text-align: center;
        }

        #roundTransitionOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .round-transition-content {
            text-align: center;
            font-family: var(--font-anime);
            color: var(--text-color);
            text-shadow: 0 0 10px var(--accent-color);
            animation: scaleIn 0.5s ease-out;
        }

        .round-number {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px var(--accent-color));
        }

        .round-difficulty {
            font-size: 36px;
            color: var(--highlight-color);
            margin-bottom: 30px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .countdown {
            font-size: 48px;
            color: var(--accent-color);
            animation: pulse 1s infinite;
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #backpackGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 5px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
        }

        .backpack-slot {
            background: #3c3c3c;
            color: #333;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            border: 2px solid #f16ce3;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            position: relative;
        }

            .backpack-slot:hover {
                background: #ddd;
                transform: scale(1.05);
            }

            .backpack-slot .slot-number {
                position: absolute;
                top: 2px;
                left: 2px;
                font-size: 10px;
                color: #666;
            }

        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: transparent;
            padding: 10px 0;
            overflow: hidden;
            z-index: 150;
        }

        .animated-banner {
            display: flex;
            width: max-content;
            animation: scrollBanner 20s linear infinite;
        }

            .animated-banner img {
                margin: 0 20px;
                max-height: 50px;
            }

        @keyframes scrollBanner {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        #walletVerifyModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        @keyframes glowPulse {
            0% {
                box-shadow: 0 0 5px var(--accent-color);
            }

            50% {
                box-shadow: 0 0 20px var(--highlight-color);
            }

            100% {
                box-shadow: 0 0 5px var(--accent-color);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite, glowPulse 2s ease-in-out infinite;
        }

        @keyframes borderHue {
            0% {
                --animated-border-color: hsl(0,100%,60%);
            }

            25% {
                --animated-border-color: hsl(120,100%,60%);
            }

            50% {
                --animated-border-color: hsl(240,100%,60%);
            }

            75% {
                --animated-border-color: hsl(300,100%,60%);
            }

            100% {
                --animated-border-color: hsl(360,100%,60%);
            }
        }

        .hue-border {
            animation: borderHue 5s linear infinite;
            border-color: var(--animated-border-color) !important;
        }

        /* Item Description Tooltip */
        .item-tooltip {
            position: absolute;
            left: 50%;
            bottom: 120%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            animation: tooltipGlow 2s infinite;
        }

        .backpack-slot:hover .item-tooltip {
            opacity: 1;
            visibility: visible;
            bottom: 130%;
        }

        @keyframes tooltipGlow {
            0% { box-shadow: 0 0 10px var(--accent-color); }
            50% { box-shadow: 0 0 20px var(--highlight-color); }
            100% { box-shadow: 0 0 10px var(--accent-color); }
        }

        .item-tooltip-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .item-tooltip-icon {
            font-size: 32px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            min-width: 50px;
            text-align: center;
        }

        .item-tooltip-details {
            flex: 1;
        }

        .item-tooltip-title {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .item-tooltip-description {
            font-family: 'Sawarabi Mincho', serif;
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.4;
        }

        .item-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--accent-color);
        }

        /* Leaderboard Styles */
        #homeLeaderboardList, #combinedLeaderboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: 'Sawarabi Mincho', serif;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }

        .leaderboard-entry:hover {
            transform: scale(1.02);
            background: rgba(0, 0, 0, 0.5);
        }

        .leaderboard-rank {
            font-family: 'Press Start 2P', cursive;
            color: var(--highlight-color);
            font-size: 10px;
            margin-right: 8px;
        }

        .leaderboard-username {
            flex: 1;
            font-weight: bold;
        }

        .leaderboard-score {
            color: var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }

        .backpack-slot {
            position: relative;
        }

        /* Achievements Styles */
        .achievements-list {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--accent-color);
        }

        .achievement-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            text-align: center;
            animation: achievementGlow 2s infinite;
        }

        @keyframes achievementGlow {
            0% { box-shadow: 0 0 5px var(--highlight-color); }
            50% { box-shadow: 0 0 15px var(--highlight-color); }
            100% { box-shadow: 0 0 5px var(--highlight-color); }
        }

        .profile-leaderboard {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .profile-leaderboard h3 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-color);
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .top-scores {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Item Directory Styles */
        .item-directory-entry {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .item-directory-entry:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--highlight-color);
        }

        .item-icon {
            font-size: 24px;
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid var(--accent-color);
        }

        .item-info {
            flex: 1;
            min-width: 0; /* Prevents flex item from overflowing */
        }

        .item-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .item-description {
            font-size: 10px;
            color: var(--text-color);
            line-height: 1.3;
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .item-rarity {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
            font-family: 'Press Start 2P', cursive;
        }

        /* Rarity colors with improved visibility */
        .common {
            color: #ffffff;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        }

        .rare {
            color: #00ffff;
            text-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
        }

        .epic {
            color: #ff00ff;
            text-shadow: 0 0 4px rgba(255, 0, 255, 0.6);
        }

        .legendary {
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
        }

        /* Improved scrollbar styling */
        #itemDirectoryListHome::-webkit-scrollbar {
            width: 6px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        #itemDirectoryListHome::-webkit-scrollbar-thumb:hover {
            background: var(--highlight-color);
        }

        /* Add hover effect to show full description */
        .item-directory-entry:hover .item-description {
            -webkit-line-clamp: unset;
            position: relative;
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            margin-top: 2px;
        }

        /* Enhanced border animation */
        @keyframes borderHue {
            0% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
            25% { border-color: hsl(220, 100%, 70%); box-shadow: 0 0 20px hsl(220, 100%, 70%); }
            50% { border-color: hsl(120, 100%, 70%); box-shadow: 0 0 20px hsl(120, 100%, 70%); }
            75% { border-color: hsl(40, 100%, 70%); box-shadow: 0 0 20px hsl(40, 100%, 70%); }
            100% { border-color: hsl(320, 100%, 70%); box-shadow: 0 0 20px hsl(320, 100%, 70%); }
        }

        .hue-border {
            animation: borderHue 8s linear infinite;
            position: relative;
        }

        .hue-border::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: inherit;
            background: linear-gradient(45deg, 
                hsla(320, 100%, 70%, 0.5),
                hsla(220, 100%, 70%, 0.5),
                hsla(120, 100%, 70%, 0.5),
                hsla(40, 100%, 70%, 0.5)
            );
            filter: blur(8px);
            opacity: 0.5;
            z-index: -1;
            animation: borderGlow 8s linear infinite;
        }

        @keyframes borderGlow {
            0% { filter: blur(8px) hue-rotate(0deg); }
            100% { filter: blur(8px) hue-rotate(360deg); }
        }

        /* Enhanced title design */
        #homeScreenContainer h1 {
            font-family: 'Bangers', cursive;
            font-size: 72px;
            text-align: center;
            margin: 20px 0;
            color: transparent;
            background: linear-gradient(
                45deg,
                #ff69b4,
                #ff1493,
                #ff69b4,
                #ff1493
            );
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            text-shadow: 
                3px 3px 0 rgba(255,20,147,0.2),
                -3px -3px 0 rgba(255,105,180,0.2),
                6px 6px 10px rgba(0,0,0,0.3);
            position: relative;
            animation: titleGradient 4s ease infinite;
            letter-spacing: 2px;
        }

        @keyframes titleGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #homeScreenContainer h1::before {
            content: 'ユミポップ';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-family: 'Sawarabi Mincho', serif;
            color: #ff69b4;
            opacity: 0.8;
            text-shadow: none;
            letter-spacing: 4px;
        }

        #homeScreenContainer h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 2px;
            background: linear-gradient(
                90deg,
                transparent,
                #ff69b4,
                #ff1493,
                #ff69b4,
                transparent
            );
        }

        /* Enhanced panel transitions */
        .info-box {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .info-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: left 0.5s ease;
        }

        .info-box:hover::before {
            left: 100%;
        }

        .info-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        /* Enhanced background effects */
        #startScreen {
            position: relative;
            overflow: hidden;
        }

        #startScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, 
                    rgba(255,105,180,0.1),
                    rgba(255,20,147,0.1)
                ),
                url('assets/images/custom-background.png');
            background-size: cover;
            filter: brightness(0.9) contrast(1.1);
            z-index: -1;
            animation: backgroundPulse 10s ease infinite;
        }

        @keyframes backgroundPulse {
            0% { filter: brightness(0.9) contrast(1.1) hue-rotate(0deg); }
            50% { filter: brightness(1) contrast(1.2) hue-rotate(15deg); }
            100% { filter: brightness(0.9) contrast(1.1) hue-rotate(0deg); }
        }

        /* Add sparkle effects to title */
        @keyframes sparkle {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1) rotate(180deg); opacity: 1; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .sparkle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #fff, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkle 2s linear infinite;
        }

        /* Add this JavaScript to create sparkles */
        function createSparkles() {
            const title = document.querySelector('#homeScreenContainer h1');
            const sparkleCount = 3;
            
            setInterval(() => {
                for (let i = 0; i < sparkleCount; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    const x = Math.random() * title.offsetWidth;
                    const y = Math.random() * title.offsetHeight;
                    
                    sparkle.style.left = x + 'px';
                    sparkle.style.top = y + 'px';
                    sparkle.style.animationDelay = Math.random() * 2 + 's';
                    
                    title.appendChild(sparkle);
                    
                    setTimeout(() => sparkle.remove(), 2000);
                }
            }, 500);
        }

        /* Mobile Optimization Styles */
        @media (max-width: 768px) {
            #leftPanel, #sidebar {
                display: none;
            }
            
            #mainContainer {
                padding: 0;
                width: 100vw;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            
            #gameCanvas {
                touch-action: none;
                width: 100%;
                height: 100%;
            }
            
            #backpackHudFullScreen {
                transform: scale(0.8);
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%) scale(0.8);
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px;
                z-index: 100;
            }
            
            #topButtons {
                transform: scale(0.8);
                top: 10px;
                left: 50%;
                transform: translateX(-50%) scale(0.8);
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px;
                z-index: 100;
            }
            
            .backpack-slot {
                padding: 5px;
                font-size: 12px;
                min-width: 40px;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            #statsBox {
                font-size: 12px;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                top: 10px;
                z-index: 100;
            }
            
            #coinPanel {
                transform: scale(0.8);
                bottom: 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 5px 10px;
                z-index: 100;
            }

            #gameMessage {
                font-size: 14px;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                z-index: 100;
            }

            /* Hide round transition overlay on mobile */
            #roundTransitionOverlay {
                display: none !important;
            }
        }

        .mobile-mode {
            /* Mobile-specific styles */
            --button-size: 60px;
            --button-margin: 10px;
        }

        .mobile-mode #gameArea {
            touch-action: none;
        }

        .mobile-mode .control-button {
            position: fixed;
            width: var(--button-size);
            height: var(--button-size);
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            color: var(--text-color);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            touch-action: none;
        }

        .mobile-mode .move-left {
            left: var(--button-margin);
            bottom: var(--button-margin);
        }

        .mobile-mode .move-right {
            left: calc(var(--button-size) + var(--button-margin) * 2);
            bottom: var(--button-margin);
        }

        .mobile-mode .jump-button {
            right: calc(var(--button-size) + var(--button-margin) * 2);
            bottom: var(--button-margin);
        }

        .mobile-mode .shoot-button {
            right: var(--button-margin);
            bottom: var(--button-margin);
        }

        .mobile-mode .backpack-button {
            right: var(--button-margin);
            bottom: calc(var(--button-size) + var(--button-margin) * 2);
        }

        @media (max-width: 768px) {
            .mobile-mode .control-button {
                --button-size: 50px;
                --button-margin: 8px;
            }
        }

        #gameMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-color);
            padding: 15px 30px;
            border-radius: 8px;
            font-family: var(--font-anime);
            font-size: 24px;
            text-align: center;
            z-index: 100;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: messageFloat 0.5s ease-out;
        }

        #gameMessage.show {
            opacity: 1;
        }

        @keyframes messageFloat {
            from {
                transform: translate(-50%, 20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        /* Base Layout Styles */
        #mainContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            display: none;
            flex-direction: row;
            gap: 0;
            padding: 10px;
        }

/* Basic View Styles */
.basic-view #leftPanel, 
.basic-view #sidebar {
  display: none;
}
.basic-view .info-box {
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  border: 2px solid var(--accent-color);
  margin-bottom: 15px;
  padding: 15px;
  border-radius: 10px;
}
.basic-view #gameArea {
  flex: 1;
  margin: 0 10px;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 10px;
  border: 2px solid var(--accent-color);
  box-shadow: 0 0 20px rgba(70, 251, 227, 0.2);
}
.basic-view #gameCanvas {
  border: 2px solid var(--accent-color);
  box-shadow: 0 0 15px var(--accent-color);
  border-radius: 8px;
  margin: 10px;
}
.basic-view #topButtons {
  position: relative;
  margin-top: 10px;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  padding: 12px;
  border: 2px solid var(--accent-color);
  border-radius: 12px;
}
/* Hide backpack HUD in basic view */
.basic-view #backpackHudFullScreen {
  display: none;
}

        /* Full Screen View Styles */
        .fullScreen #leftPanel,
        .fullScreen #sidebar {
            display: none;
        }

        .fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            border: none;
        }

        .fullScreen #topButtons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            min-width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .fullScreen #topButtons::-webkit-scrollbar {
            width: 6px;
        }

        .fullScreen #topButtons::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        .fullScreen #topButtons::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        .fullScreen #backpackHudFullScreen {
            display: none;
        }

        .fullScreen #topButtons .section-header {
            color: var(--accent-color);
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            margin: 12px 0 8px 0;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .fullScreen #topButtons .section-content {
            margin-bottom: 15px;
        }

        .fullScreen #topButtons .backpack-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            margin: 10px 0;
        }

        .fullScreen #topButtons .backpack-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--accent-color);
            border-radius: 6px;
            padding: 8px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .fullScreen #topButtons .backpack-slot:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
            border-color: var(--highlight-color);
        }

        .fullScreen #topButtons .backpack-slot .slot-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: var(--accent-color);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .fullScreen #topButtons .backpack-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: var(--highlight-color);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .fullScreen #topButtons .item-tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--accent-color);
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 101;
            width: max-content;
            max-width: 200px;
        }

        .fullScreen #topButtons .backpack-slot:hover .item-tooltip {
            opacity: 1;
        }

        .fullScreen #topButtons.minimized {
            min-width: unset;
            width: auto;
        }

        .fullScreen #topButtons.minimized .section-content,
        .fullScreen #topButtons.minimized .divider {
            display: none;
        }

        /* Update the minimize button style */
        .fullScreen #topButtons .minimize-button {
            background: none;
            border: none;
            color: var(--accent-color);
            padding: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .fullScreen #topButtons .minimize-button:hover {
            color: var(--highlight-color);
        }

        /* Add section dividers */
        .fullScreen #topButtons .divider {
            height: 1px;
            background: var(--accent-color);
            margin: 10px 0;
            opacity: 0.5;
        }

        .fullScreen #topButtons button {
            padding: 8px 15px;
            font-size: 12px;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fullScreen #topButtons button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.02);
        }

        .fullScreen #topButtons .controls-section {
            margin-top: 10px;
        }

        .fullScreen #topButtons .controls-header {
            color: var(--accent-color);
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .fullScreen #topButtons .control-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            color: var(--text-color);
            font-size: 11px;
        }

        .fullScreen #topButtons .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--highlight-color);
            min-width: 20px;
            text-align: center;
        }

        .fullScreen #topButtons .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .fullScreen #topButtons .minimize-button {
            background: none;
            border: none;
            color: var(--accent-color);
            padding: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .fullScreen #topButtons.minimized {
            width: auto;
            min-width: unset;
        }

        .fullScreen #topButtons.minimized .button-group,
        .fullScreen #topButtons.minimized .divider,
        .fullScreen #topButtons.minimized .controls-section {
            display: none;
        }

        .fullScreen #topButtons.minimized .minimize-button {
            transform: rotate(180deg);
        }

        /* Remove the separate key map overlay since it's now integrated */
        .fullScreen #keyMapOverlay {
            display: none;
        }

        /* Ensure the game canvas takes full space */
        .fullScreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            border: none;
        }

        /* Mobile View Styles */
        @media (max-width: 768px) {
            .mobile-mode #mainContainer {
                padding: 0;
            }

            .mobile-mode #gameCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            .mobile-mode #topButtons {
                transform: scale(0.8);
                right: 5px;
                top: 5px;
                padding: 8px;
            }

            .mobile-mode #keyMapOverlay {
                transform: scale(0.8);
                left: 5px;
                top: 5px;
                padding: 8px;
            }

            .mobile-mode #statsBox {
                transform: translateX(-50%) scale(0.8);
                top: 5px;
                padding: 5px 10px;
                font-size: 10px;
            }

            .mobile-mode #backpackHudFullScreen {
                transform: translateX(-50%) scale(0.8);
                bottom: 5px;
                padding: 5px;
            }

            .mobile-mode .control-button {
                --button-size: 50px;
                position: fixed;
                width: var(--button-size);
                height: var(--button-size);
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid var(--accent-color);
                border-radius: 50%;
                color: var(--text-color);
                font-size: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                touch-action: none;
            }

            .mobile-mode .move-left {
                left: 10px;
                bottom: 10px;
            }

            .mobile-mode .move-right {
                left: 70px;
                bottom: 10px;
            }

            .mobile-mode .jump-button {
                right: 70px;
                bottom: 10px;
            }

            .mobile-mode .shoot-button {
                right: 10px;
                bottom: 10px;
            }

            .mobile-mode .backpack-button {
                right: 10px;
                bottom: 70px;
            }
        }

        /* iOS Specific Adjustments */
        @supports (-webkit-touch-callout: none) {
            .mobile-mode #mainContainer {
                height: -webkit-fill-available;
            }

            .mobile-mode .control-button {
                padding: env(safe-area-inset-bottom);
            }

            .mobile-mode #backpackHudFullScreen {
                bottom: calc(env(safe-area-inset-bottom) + 5px);
            }
        }

        /* Shared UI Element Styles */
        .ui-element {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .ui-element:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }

        /* Button Styles */
        .game-button {
            padding: 8px 15px;
            font-size: 12px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .game-button:hover {
            background: rgba(70, 251, 227, 0.2);
            transform: scale(1.05);
        }

        /* Add view mode detection and switching logic */
        <script>
  function updateViewMode() {
    const mainContainer = document.getElementById('mainContainer');
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const isTablet = window.innerWidth <= 1024 && window.innerWidth > 768;
    const isFullScreen = document.fullscreenElement !== null;
    
    mainContainer.classList.remove('basic-view', 'fullScreen', 'mobile-mode', 'tablet-mode');
    
    if (isMobile || isTablet) {
      mainContainer.classList.add(isMobile ? 'mobile-mode' : 'tablet-mode');
      enableTouchControls();
      adjustForMobileUI();
    } else if (isFullScreen) {
      mainContainer.classList.add('fullScreen');
      disableTouchControls();
    } else {
      mainContainer.classList.add('basic-view');
      disableTouchControls();
    }
    
    adjustCanvasSize();
    updateBackpackUI();
    updateMobileOrientation();
  }

  function updateMobileOrientation() {
    const isLandscape = window.innerWidth > window.innerHeight;
    document.body.classList.toggle('landscape', isLandscape);
    document.body.classList.toggle('portrait', !isLandscape);
    
    if (window.innerWidth <= 768) {
      const message = isLandscape ? '' : 'Please rotate your device to landscape mode for better gameplay';
      const orientationMsg = document.getElementById('orientationMessage') || createOrientationMessage();
      orientationMsg.textContent = message;
      orientationMsg.style.display = isLandscape ? 'none' : 'block';
    }
  }

  function createOrientationMessage() {
    const msg = document.createElement('div');
    msg.id = 'orientationMessage';
    msg.className = 'game-message';
    document.body.appendChild(msg);
    return msg;
  }

  function adjustForMobileUI() {
    const gameCanvas = document.getElementById('gameCanvas');
    if (!gameCanvas) return;

    // Prevent default touch behaviors
    gameCanvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
    gameCanvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    
    // Adjust UI scaling based on device
    const scaleFactor = Math.min(window.innerWidth / 1000, window.innerHeight / 600);
    document.documentElement.style.setProperty('--ui-scale', scaleFactor.toString());
    
    // Enable touch controls
    setupTouchControls();
  }

  function enableTouchControls() {
    const touchControls = document.querySelectorAll('.control-button');
    touchControls.forEach(button => {
      button.style.display = 'flex';
    });
  }

  function disableTouchControls() {
    const touchControls = document.querySelectorAll('.control-button');
    touchControls.forEach(button => {
      button.style.display = 'none';
    });
  }

  // Event Listeners for Mobile Detection
  window.addEventListener('resize', updateViewMode);
  window.addEventListener('orientationchange', updateViewMode);
  document.addEventListener('fullscreenchange', updateViewMode);
  document.addEventListener('DOMContentLoaded', updateViewMode);
</script>

        /* Loading overlay styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: var(--accent-color);
            font-family: var(--font-anime);
            padding: 20px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.7);
        }

        .loading-progress {
            width: min(300px, 80vw);
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(45deg, var(--accent-color), var(--highlight-color));
            transition: width 0.3s ease;
        }

        .loading-text {
            font-size: min(14px, 3.5vw);
            margin-top: 10px;
            color: var(--text-color);
        }

        @media (max-width: 768px) {
            .loading-content h2 {
                font-size: 5vw;
            }
        }

        // Add to the script section
        async function initializeGame() {
            // Show loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'loading-overlay';
            loadingOverlay.innerHTML = `
                <div class="loading-content">
                    <h2>Loading Yumi Pop</h2>
                    <div class="loading-progress">
                        <div class="progress-bar"></div>
                    </div>
                    <div class="loading-text">Loading assets...</div>
                </div>
            `;
            document.body.appendChild(loadingOverlay);

            const progressBar = loadingOverlay.querySelector('.progress-bar');
            const loadingText = loadingOverlay.querySelector('.loading-text');

            try {
                // Initialize Firebase
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }

                // Load and cache game assets
                const assets = {
                    images: [
                        'assets/images/custom-background.png',
                        'assets/images/canvas-background.png',
                        'assets/images/character1_portrait.gif',
                        'assets/images/character2_portrait.gif',
                        'assets/images/character3_portrait.gif',
                        'assets/images/character4_portrait.gif',
                        'assets/images/character5_portrait.gif',
                        'assets/images/floor.png',
                        'assets/images/start_cutscene.png',
                        'assets/images/boss_cutscene.png'
                    ],
                    sounds: [
                        'assets/sounds/pop.wav',
                        'assets/sounds/powerup.wav',
                        'assets/sounds/special.wav',
                        'assets/sounds/death.wav',
                        'assets/sounds/bubbleSplit.wav',
                        'assets/sounds/Backgroundmusic1.wav',
                        'assets/sounds/Backgroundmusic2.wav',
                        'assets/sounds/Backgroundmusic3.wav',
                        'assets/sounds/Backgroundmusic4.wav',
                        'assets/sounds/bossMusic.wav',
                        'assets/sounds/homeBgmusic.wav'
                    ]
                };

                const totalAssets = assets.images.length + assets.sounds.length;
                let loadedAssets = 0;

                function updateProgress() {
                    const progress = (loadedAssets / totalAssets) * 100;
                    progressBar.style.width = `${progress}%`;
                    loadingText.textContent = `Loading assets... ${Math.floor(progress)}%`;
                }

                // Load images
                await Promise.all(assets.images.map(src => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        assetCache[src] = img;
                        loadedAssets++;
                        updateProgress();
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${src}`);
                        loadedAssets++;
                        updateProgress();
                        resolve();
                    };
                    img.src = src;
                })));

                // Load sounds
                await Promise.all(assets.sounds.map(src => new Promise((resolve, reject) => {
                    const audio = new Audio();
                    audio.oncanplaythrough = () => {
                        loadedAssets++;
                        updateProgress();
                        resolve();
                    };
                    audio.onerror = () => {
                        console.warn(`Failed to load sound: ${src}`);
                        loadedAssets++;
                        updateProgress();
                        resolve();
                    };
                    audio.src = src;
                })));

                // Initialize UI elements
                document.getElementById('startScreen').style.display = 'flex';
                populateItemDirectory();
                setupEventListeners();
                
                // Remove loading overlay with fade effect
                loadingOverlay.style.opacity = '0';
                setTimeout(() => loadingOverlay.remove(), 500);

            } catch (error) {
                console.error('Initialization error:', error);
                loadingText.textContent = 'Error loading game. Please refresh the page.';
                loadingText.style.color = 'red';
            }
        }

        function setupEventListeners() {
            // Character selection handler
            document.getElementById('characterSelect').addEventListener('change', function(e) {
                const portrait = document.getElementById('homeProfilePic');
                portrait.src = portraitMap[e.target.value];
            });

            // Username input handler
            document.getElementById('usernameInput').addEventListener('input', function(e) {
                const name = e.target.value.trim();
                document.getElementById('homeProfileUsername').innerText = name ? `Username: ${name}` : 'Username: Guest';
            });

            // Start button handler with validation
            document.getElementById('startButton').addEventListener('click', async function() {
                const username = document.getElementById('usernameInput').value.trim();
                const startError = document.getElementById('startError');
                
                if (!username) {
                    startError.innerText = 'Please enter a username.';
                    return;
                }
                
                startError.innerText = '';
                try {
                    await startGame();
                } catch (error) {
                    console.error('Error starting game:', error);
                    startError.innerText = 'Failed to start game. Please try again.';
                }
            });

            // Settings handlers
            document.getElementById('bgMusicToggle').addEventListener('change', function(e) {
                bgMusicOn = e.target.checked;
                if (bgMusicOn) {
                    homeBgMusic.play();
                } else {
                    homeBgMusic.pause();
                }
                localStorage.setItem('bgMusicOn', bgMusicOn);
            });

            document.getElementById('sfxToggle').addEventListener('change', function(e) {
                sfxOn = e.target.checked;
                localStorage.setItem('sfxOn', sfxOn);
            });

            // Load saved settings
            const savedBgMusic = localStorage.getItem('bgMusicOn');
            const savedSfx = localStorage.getItem('sfxOn');
            if (savedBgMusic !== null) {
                document.getElementById('bgMusicToggle').checked = savedBgMusic === 'true';
                bgMusicOn = savedBgMusic === 'true';
            }
            if (savedSfx !== null) {
                document.getElementById('sfxToggle').checked = savedSfx === 'true';
                sfxOn = savedSfx === 'true';
            }
        }

        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', initializeGame);

        async function startGame() {
            const username = document.getElementById('usernameInput').value.trim();
            currentCharacterSelection = document.getElementById('characterSelect').value;
            
            document.getElementById('homeProfilePic').src = portraitMap[currentCharacterSelection];
            document.getElementById('homeProfileUsername').innerText = `Username: ${username}`;
            document.getElementById('startScreen').style.display = 'none';

            // Handle music transition
            homeBgMusic.pause();
            bgMusic.volume = 0;
            bgMusic.play();
            
            let fadeInterval = setInterval(() => {
                if (bgMusic.volume < parseFloat(document.getElementById('bgVolume').value)) {
                    bgMusic.volume = Math.min(bgMusic.volume + 0.1, parseFloat(document.getElementById('bgVolume').value));
                } else {
                    clearInterval(fadeInterval);
                }
            }, 100);

            updateGameState(GameState.CUTSCENE);
            await showCutscene('start');
            
            document.getElementById('mainContainer').style.display = 'flex';
            document.getElementById('gameCanvas').style.display = 'block';
            
            await initGame(currentCharacterSelection);
            
            document.getElementById('profilePic').src = portraitMap[currentCharacterSelection];
            updateCoinPanel();
            
            startRoundTimer();
            updateGameState(GameState.PLAYING);
            lastFrameTime = performance.now();
            gameLoop();
        }
    </style>
    <script>
        /* Add this JavaScript to create sparkles */
        function createSparkles() {
            const title = document.querySelector('#homeScreenContainer h1');
            const sparkleCount = 3;
            
            setInterval(() => {
                for (let i = 0; i < sparkleCount; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    const x = Math.random() * title.offsetWidth;
                    const y = Math.random() * title.offsetHeight;
                    
                    sparkle.style.left = x + 'px';
                    sparkle.style.top = y + 'px';
                    sparkle.style.animationDelay = Math.random() * 2 + 's';
                    
                    title.appendChild(sparkle);
                    
                    setTimeout(() => sparkle.remove(), 2000);
                }
            }, 500);
        }
    </script>
</head>
<body>
    <!-- Wallet Verification Modal -->
    <div id="walletVerifyModal" class="hue-border"></div>
    <!-- Cutscene Overlay -->
    <div id="cutscene" class="hue-border">
        <div id="cutsceneContent"></div>
        <button id="skipCutscene">Skip</button>
    </div>
    <!-- Start Screen -->
    <div id="startScreen" class="hue-border">
        <div id="homeScreenContainer" class="info-box hue-border">
            <div id="mainContent">
            <h1>Yumi Pop</h1>
            <div id="homeInputSection">
                <label>
                    Username:
                    <input type="text" id="usernameInput" placeholder="Enter your username" />
                </label>
                <label>
                    Choose Character:
                    <select id="characterSelect">
                        <option value="character1">Yumi</option>
                        <option value="character2">Kaji</option>
                        <option value="character3">Nova</option>
                        <option value="character4">Sol</option>
                        <option value="character5">Reek</option>
                    </select>
                </label>
            </div>
            <div id="walletAndStartSection" class="info-box hue-border">
                <button id="connectWalletButton">Connect Wallet</button>
                <button id="disconnectWalletButton" style="display: none;">Disconnect Wallet</button>
                <span id="walletAddressDisplay">Not Connected</span>
                <label class="fullScreenToggle" style="margin:0;">
                    <input type="checkbox" id="fullScreenToggle"> Full Screen Mode
                </label>
                <label class="mobileToggle" style="margin:0;">
                    <input type="checkbox" id="mobileToggle"> Mobile Mode
                </label>
                <button id="startButton">Start Game</button>
            </div>
            <div id="profilePreviewSection" class="info-box hue-border">
                <div class="profile">
                    <img id="homeProfilePic" src="assets/images/character1_portrait.gif" alt="Profile Picture">
                    <div class="profile-info">
                        <p id="homeProfileUsername">Username: Guest</p>
                        <p id="homeProfileWallet">Wallet: Not Connected</p>
                        <p id="homeProfileLevel">Level: 1</p>
                        <p id="homeProfileTopScore">Top Score: 0</p>
                    </div>
                </div>
            </div>
            <!-- Leaderboard Section -->
                <div id="homeLeaderboard" class="info-box hue-border">
                    <h3>Top 10 Players</h3>
                    <div id="homeLeaderboardList"></div>
                </div>
            </div>
            <div id="itemDirectorySection" class="hue-border">
                <h3>Item Directory</h3>
                <div id="itemDirectoryListHome"></div>
            </div>
        </div>
        <div id="startError" style="color:red; margin-top:10px;"></div>
    </div>
    <!-- Main Game Container -->
    <div id="mainContainer" class="game-container">
        <!-- Mobile Controls -->
        <div id="mobileControls" class="mobile-controls">
            <div id="moveLeft" class="control-button left-button">
                <span>←</span>
            </div>
            <div id="moveRight" class="control-button right-button">
                <span>→</span>
            </div>
            <div id="moveUp" class="control-button up-button">
                <span>↑</span>
            </div>
            <div id="moveDown" class="control-button down-button">
                <span>↓</span>
            </div>
            <div id="actionButton" class="control-button action-button">
                <span>A</span>
            </div>
            <div id="specialButton" class="control-button special-button">
                <span>S</span>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Mobile Game UI -->
        <div class="mobile-game-ui">
            <div class="top-bar">
                <div id="scoreDisplay">Score: 0</div>
                <div id="timerDisplay">Time: 0:00</div>
                <div id="levelDisplay">Level: 1</div>
            </div>
            <div class="bottom-bar">
                <div id="healthBar" class="health-bar">
                    <div class="health-fill"></div>
                </div>
                <div id="specialBar" class="special-bar">
                    <div class="special-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Mobile Controls Styles */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 1000;
        }

        .mobile-mode .mobile-controls {
            display: flex;
        }

        .control-button {
            width: 60px;
            height: 60px;
            background: rgba(70, 251, 227, 0.2);
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
            font-size: 24px;
            pointer-events: auto;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .control-button:active {
            background: rgba(70, 251, 227, 0.4);
            transform: scale(0.95);
        }

        .left-button { left: 20px; }
        .right-button { left: 100px; }
        .up-button { right: 100px; }
        .down-button { right: 20px; }
        .action-button { 
            bottom: 80px;
            right: 20px;
            background: rgba(255, 95, 212, 0.2);
            border-color: var(--highlight-color);
        }
        .special-button {
            bottom: 80px;
            right: 100px;
            background: rgba(255, 95, 212, 0.2);
            border-color: var(--highlight-color);
        }

        /* Mobile Game UI Styles */
        .mobile-game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 900;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: var(--text-color);
            font-family: var(--font-anime);
            font-size: min(14px, 3.5vw);
        }

        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 10px;
        }

        .health-bar,
        .special-bar {
            height: 20px;
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff5959, #ff8f8f);
            transition: width 0.3s ease;
        }

        .special-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--highlight-color), #ff8fef);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .mobile-game-ui {
                display: block;
            }
            
            .control-button {
                width: min(60px, 15vw);
                height: min(60px, 15vw);
                font-size: min(24px, 6vw);
            }

            .bottom-bar {
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }
        }

        @media (min-width: 769px) {
            .mobile-game-ui {
                display: none;
            }
        }
    </style>

    <aside id="leftPanel" class="control-panel">
        <div class="section-header">Profile</div>
        <div class="section-content">
            <div id="profileBox" class="info-box">
                <div class="profile">
                    <img id="profilePic" src="assets/images/character1_portrait.gif" alt="Profile Picture" style="width:50px; height:50px; border:2px solid var(--accent-color); border-radius:50%;">
                    <div class="profile-info">
                        <p id="profileUsername">Username: </p>
                        <p id="profileWallet">Wallet: Not Connected</p>
                        <p id="profileLevel">Level: </p>
                        <p id="profileTopScore">Top Score: </p>
                    </div>
                </div>
                <div class="scoreboard">
                    <p id="scoreText">Score: 0</p>
                    <p id="livesText">Lives: 3</p>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <div class="section-header">Backpack</div>
        <div class="section-content">
            <div id="backpackContainer" class="info-box">
                <div id="backpackGrid" class="backpack-grid">
                    <!-- Backpack slots will be dynamically added here -->
                </div>
            </div>
        </div>
    </aside>
    <main id="gameArea">
        <div id="statsBox">
          <p id="statsText">Round: 1   Lives: 3   Timer: 25s</p>
        </div>
        <div id="gameMessage"></div>
        <div id="roundTransitionOverlay" class="hue-border"></div>
        <!-- Control panel for game menu – in basic view, its relative positioning makes it appear below the canvas -->
        <div id="topButtons" class="ui-element">
          <div class="panel-header">
            <span class="controls-header">Game Menu</span>
            <button class="minimize-button" onclick="toggleControlPanel()">▼</button>
          </div>
          <div class="section-content">
            <div class="button-group">
              <button id="fsPauseButton">
                <span class="key">P</span>
                <span>Pause</span>
              </button>
              <button id="fsSettingsButton">
                <span class="key">S</span>
                <span>Settings</span>
              </button>
              <button id="fsRestartButton">
                <span class="key">R</span>
                <span>Restart</span>
              </button>
              <button id="fsHomeButton">
                <span class="key">H</span>
                <span>Home</span>
              </button>
            </div>
          </div>
          <div class="divider"></div>
          <div class="section-content">
            <div class="controls-header">Backpack</div>
            <div class="backpack-grid">
              <!-- Backpack slots will be populated dynamically -->
            </div>
          </div>
          <div class="divider"></div>
          <div class="section-content">
            <div class="controls-header">Controls</div>
            <div class="control-item">
              <span>Move Left</span>
              <span class="key">A</span>
            </div>
            <div class="control-item">
              <span>Move Right</span>
              <span class="key">D</span>
            </div>
            <div class="control-item">
              <span>Jump</span>
              <span class="key">W</span>
            </div>
            <div class="control-item">
              <span>Shoot</span>
              <span class="key">Space</span>
            </div>
            <div class="control-item">
              <span>Use Item</span>
              <span class="key">S</span>
            </div>
          </div>
        </div>
        <div id="backpackHudFullScreen" class="info-box hue-border"></div>
      </main>
    <aside id="sidebar" class="control-panel">
        <div class="section-header">
            <span>Game Controls</span>
            <button class="minimize-button">▼</button>
        </div>

        <div class="section-content">
            <div class="button-group">
                <button id="pauseButton">
                    <span class="key">P</span>
                    <span>Pause</span>
                </button>
                <button id="settingsButton">
                    <span class="key">S</span>
                    <span>Settings</span>
                </button>
                <button id="restartGameButton">
                    <span class="key">R</span>
                    <span>Restart Game</span>
                </button>
                <button id="homeScreenButton">
                    <span class="key">H</span>
                    <span>Home Screen</span>
                </button>
            </div>
        </div>

        <div class="divider"></div>

        <div class="section-header">Controls</div>
        <div class="section-content">
            <div class="control-item">
                <span>Move Left</span>
                <span class="key">A</span>
            </div>
            <div class="control-item">
                <span>Move Right</span>
                <span class="key">D</span>
            </div>
            <div class="control-item">
                <span>Jump</span>
                <span class="key">W</span>
            </div>
            <div class="control-item">
                <span>Shoot</span>
                <span class="key">Space</span>
            </div>
            <div class="control-item">
                <span>Use Item</span>
                <span class="key">S</span>
            </div>
        </div>

        <div class="divider"></div>

        <div class="section-header">Character</div>
        <div class="section-content">
            <div class="portraitContainer">
                <img src="assets/images/character1_portrait.gif" alt="Character Portrait" />
            </div>
        </div>

        <div class="divider"></div>

        <div id="achievementLog">
            <div class="section-header">Achievements</div>
            <div class="section-content achievements-list"></div>
        </div>
    </aside>
    <!-- Coin Panel -->
    <div id="coinPanel" class="hue-border">
        <span id="coinUsername"></span> | Coins: <span id="coinCount">0</span>
    </div>
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hue-border">
        <h1>Game Over</h1>
        <img id="gameOverSprite" src="assets/images/gameOver_1.png" style="width:300px;height:300px;display:block;margin:0 auto;">
        <p id="finalScore"></p>
        <h3>Leaderboard</h3>
        <ul id="gameOverLeaderboard"></ul>
        <button id="restartButton">Restart Game</button>
        <button id="homeButton">Home</button>
    </div>
    <!-- Settings Overlay -->
    <div id="settingsOverlay" class="hue-border">
        <h3>Settings</h3>
        <label><input type="checkbox" id="bgMusicToggle" checked> Background Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
        <label>Background Music Volume: <input type="range" id="bgVolume" min="0" max="1" step="0.01" value="1"></label>
        <label>Sound Effects Volume: <input type="range" id="sfxVolume" min="0" max="1" step="0.01" value="1"></label>
        <label>Custom Backdrop: <input type="file" id="customBackdrop" accept="image/*"></label>
        <label class="fullScreenToggle"><input type="checkbox" id="fullScreenToggleSettings"> Full Screen Mode</label>
        <label class="mobileToggle"><input type="checkbox" id="mobileToggleSettings"> Mobile Mode</label>
        <h4>Control Settings</h4>
        <label>Move Left: <input type="text" id="keyLeft" value="a" maxlength="1"></label>
        <label>Move Right: <input type="text" id="keyRight" value="d" maxlength="1"></label>
        <label>Jump: <input type="text" id="keyJump" value="w" maxlength="1"></label>
        <label>Shoot: <input type="text" id="keyShoot" value=" " maxlength="1"> (Space/Left Click)</label>
        <label>Backpack: <input type="text" id="keyBackpack" value="s" maxlength="1"></label>
        <label>Custom Music: <input type="file" id="customMusic" accept="audio/*"></label>
        <label>Leaderboard Reset Interval (minutes): <input type="number" id="resetInterval" value="5" min="1" step="1"></label>
        <button id="closeSettings">Close</button>
    </div>
    <!-- Footer Animated Banner -->
    <footer>
        <div class="animated-banner">
            <a href="https://x.com/Yumi__One" target="_blank">
                <img src="assets/images/logo1.jpg" alt="Project Logo 1">
            </a>
            <a href="https://yumipop.netlify.app" target="_blank">
                <img src="assets/images/logo2.png" alt="Project Logo 2">
            </a>
            <a href="https://www.eclipse.xyz/" target="_blank">
                <img src="assets/images/logo3.jpg" alt="Project Logo 3">
            </a>
            <a href="https://eclipse.solarstudios.co/swap" target="_blank">
                <img src="assets/images/logo4.jpg" alt="Project Logo 4">
            </a>
        </div>
    </footer>
    <!-- JavaScript: Game Logic, Firebase Integration, WalletConnect & Sockets -->
    <script>
  (function() {
    "use strict";

    // Utility Functions
    function showGameMessage(message) {
      const msgDiv = document.getElementById("gameMessage");
      msgDiv.textContent = message;
      msgDiv.classList.add("show");
      setTimeout(() => {
        msgDiv.classList.remove("show");
      }, 2000);
    }
    function checkLevelUp() {
      while (xp >= xpLevel * 100) {
        xp -= xpLevel * 100;
        xpLevel++;
        bonusGameOpportunities++;
        addAchievement("Level Up! Now Player Level " + xpLevel + ". Bonus game available!");
        updateBonusGameUI();
        updateProfileBox();
      }
    }

    // Socket.IO Setup (for additional networking if needed)
    const socket = io('http://localhost:3000');
    socket.on('connect', () => { console.log("Connected to socket server"); });

    // Wallet Integration
    let playerWalletAddress = null;

    async function connectWallet() {
        try {
            // Check if already connected
            if (playerWalletAddress) {
                showGameMessage("Wallet already connected!");
                return;
            }

            // Check if MetaMask or other Web3 provider is available
            if (!window.ethereum) {
                showGameMessage("Please install MetaMask or another Web3 wallet!");
                window.open('https://metamask.io/download/', '_blank');
                return;
            }

            // Request account access
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });

            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            
            // Update UI
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            document.getElementById("connectWalletButton").style.display = "none";
            document.getElementById("disconnectWalletButton").style.display = "block";

            // Update Firebase record with wallet address
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }

            showGameMessage("Wallet connected successfully!");

            // Setup event listeners for wallet
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
            window.ethereum.on('disconnect', handleDisconnect);

        } catch (error) {
            console.error("Wallet connect error: ", error);
            document.getElementById("walletAddressDisplay").innerText = "Connection Failed";
            showGameMessage("Failed to connect wallet: " + error.message);
        }
    }

    async function disconnectWallet() {
        try {
            playerWalletAddress = null;

            // Update UI
            document.getElementById("walletAddressDisplay").innerText = "Not Connected";
            document.getElementById("homeProfileWallet").innerText = "Wallet: Not Connected";
            document.getElementById("connectWalletButton").style.display = "block";
            document.getElementById("disconnectWalletButton").style.display = "none";

            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: ""
                });
            }

            showGameMessage("Wallet disconnected");

            // Remove event listeners
            if (window.ethereum) {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
                window.ethereum.removeListener('disconnect', handleDisconnect);
            }
        } catch (error) {
            console.error("Error disconnecting wallet:", error);
        }
    }

    // Wallet event handlers
    function handleAccountsChanged(accounts) {
        if (accounts.length === 0) {
            disconnectWallet();
        } else if (accounts[0] !== playerWalletAddress) {
            playerWalletAddress = accounts[0];
            const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
            document.getElementById("walletAddressDisplay").innerText = shortAddress;
            document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
            
            // Update Firebase record
            if (username) {
                const leaderboardRef = firebase.database().ref('leaderboard');
                leaderboardRef.child(username.toLowerCase()).update({
                    walletAddress: playerWalletAddress.toLowerCase()
                });
            }
        }
    }

    function handleChainChanged() {
        // Reload the page when chain changes
        window.location.reload();
    }

    function handleDisconnect() {
        disconnectWallet();
    }

    // Add wallet button event listeners
    document.getElementById("connectWalletButton").addEventListener("click", connectWallet);
    document.getElementById("disconnectWalletButton").addEventListener("click", disconnectWallet);

    // Check if already connected on page load
    document.addEventListener('DOMContentLoaded', async () => {
        if (window.ethereum) {
            try {
                const accounts = await window.ethereum.request({ 
                    method: 'eth_accounts' 
                });
                if (accounts.length > 0) {
                    playerWalletAddress = accounts[0];
                    const shortAddress = playerWalletAddress.slice(0, 6) + "..." + playerWalletAddress.slice(-4);
                    document.getElementById("walletAddressDisplay").innerText = shortAddress;
                    document.getElementById("homeProfileWallet").innerText = "Wallet: " + shortAddress;
                    document.getElementById("connectWalletButton").style.display = "none";
                    document.getElementById("disconnectWalletButton").style.display = "block";
                }
            } catch (error) {
                console.error("Error checking wallet connection:", error);
            }
        }
    });

    // Firebase Leaderboard Functions
    function firebaseSubmitScore() {
      // Use wallet address as identifier if available, otherwise use username
      const identifier = playerWalletAddress ? playerWalletAddress.toLowerCase() : username.toLowerCase();
      const record = {
        username: username,
        score: score,
        rounds: level,
        timeSurvived: 25 - roundTimeRemaining,
        xp: xp,
        xpLevel: xpLevel,
        bonusOpportunities: bonusGameOpportunities,
        coins: coinsCollected,
        walletAddress: playerWalletAddress ? playerWalletAddress.toLowerCase() : "",
        profilePic: document.getElementById("homeProfilePic").src,
        lastUpdated: new Date().toISOString()
      };

      const leaderboardRef = firebase.database().ref('leaderboard');
      
      // First check if there's an existing record with this wallet address
      if (playerWalletAddress) {
        leaderboardRef.orderByChild('walletAddress')
          .equalTo(playerWalletAddress.toLowerCase())
          .once('value', function(snapshot) {
            if (snapshot.exists()) {
              // Update existing record if new score is higher
              snapshot.forEach(function(childSnapshot) {
                const existing = childSnapshot.val();
                if (score > existing.score) {
                  leaderboardRef.child(childSnapshot.key).update(record);
                }
              });
            } else {
              // No existing record with this wallet, create new
              leaderboardRef.child(identifier).set(record);
            }
          });
      } else {
        // No wallet connected, use username-based record
        leaderboardRef.child(identifier).once('value', function(snapshot) {
          if (snapshot.exists()) {
            const existing = snapshot.val();
            if (score > existing.score) {
              leaderboardRef.child(identifier).update(record);
            }
          } else {
            leaderboardRef.child(identifier).set(record);
          }
        });
      }

      // After submission, refresh leaderboards
      fetchHomeLeaderboard();
      populateGameOverLeaderboardFirebase();
    }

    function firebaseFetchLeaderboard(callback) {
      const leaderboardRef = firebase.database().ref('leaderboard');
      leaderboardRef.once('value', function(snapshot) {
        const leaderboardArray = [];
        const processedWallets = new Set(); // To prevent duplicate entries for same wallet

        snapshot.forEach(function(childSnapshot) {
          const entry = childSnapshot.val();
          
          // If entry has wallet address, check if we've already processed it
          if (entry.walletAddress && processedWallets.has(entry.walletAddress)) {
            return; // Skip duplicate wallet entries
          }
          
          if (entry.walletAddress) {
            processedWallets.add(entry.walletAddress);
          }
          
          leaderboardArray.push(entry);
        });

        // Sort by composite score (rounds, score, time survived)
        leaderboardArray.sort((a, b) => {
          const aScore = (a.rounds * 0.6) + (a.score * 0.0003) + (a.timeSurvived * 0.001);
          const bScore = (b.rounds * 0.6) + (b.score * 0.0003) + (b.timeSurvived * 0.001);
          return bScore - aScore;
        });

        callback(leaderboardArray.slice(0, 10));
      });
    }

    function populateGameOverLeaderboardFirebase() {
      firebaseFetchLeaderboard(function(leaderboardData) {
        const goList = document.getElementById("gameOverLeaderboard");
        goList.innerHTML = "";
        leaderboardData.forEach(entry => {
          const li = document.createElement("li");
          const walletDisplay = entry.walletAddress ? 
            `(${entry.walletAddress.slice(0, 6)}...${entry.walletAddress.slice(-4)})` : 
            '';
          li.innerHTML = `
            <img src="${entry.profilePic || 'assets/images/character1_portrait.gif'}" 
                 alt="Profile" 
                 style="width:20px;height:20px;border-radius:50%;">
            ${entry.username} ${walletDisplay} | Rounds: ${entry.rounds} | 
            Score: ${Math.floor(entry.score)} | Time: ${entry.timeSurvived}s
          `;
          goList.appendChild(li);
        });
      });
    }
    window.addEventListener("load", fetchHomeLeaderboard);

    // Global Game Variables
    const BASE_BUBBLE_SPEED = 1.5;
    const SPEED_INCREASE_PER_LEVEL = 0.03;
    const MAX_BUBBLE_SPEED = 5;
    const HIT_COOLDOWN = 1000;
    const MAX_LIVES = 9;
    const AUTO_FIRE_DURATION = 10000;
    const AUTO_FIRE_INTERVAL_MS = 300;
    const SHOOT_ANIMATION_DURATION = 300;
    const BOSS_HEALTH_BASE = 3;
    let roundTimeRemaining = 25;
    let timerInterval = null;
    let autoFireActive = false;
    let autoFireInterval = null;
    let roundTransitionInProgress = false;
    let difficultyFactor = 1.0;
    let currentDifficulty = "Easy";
    let coinsCollected = 0;
    let laserFireActive = false;
    let laserFireTimeout;
    let freezeActive = false;
    const GameState = { START: 'start', PLAYING: 'playing', CUTSCENE: 'cutscene', PAUSED: 'paused', GAME_OVER: 'game_over' };
    let currentState = GameState.START;
    function updateGameState(newState) {
      currentState = newState;
      if (currentState === GameState.PLAYING) gameLoop();
    }
    let backpackInventory = {};
    const assetCache = {};
    function preloadImage(src) {
      if (!assetCache[src]) {
        const img = new Image();
        img.src = src;
        assetCache[src] = img;
      }
      return assetCache[src];
    }
    // Preload Assets
    preloadImage('assets/images/custom-background.png');
    preloadImage('assets/images/canvas-background.png');
    preloadImage('assets/images/character1_portrait.gif');
    preloadImage('assets/images/character2_portrait.gif');
    preloadImage('assets/images/character3_portrait.gif');
    preloadImage('assets/images/character4_portrait.gif');
    preloadImage('assets/images/character5_portrait.gif');
    preloadImage("assets/images/floor.png");
    preloadImage("assets/images/start_cutscene.jpeg");
    preloadImage("assets/images/boss_cutscene.jpeg");
    function spritePNG(assetName) {
      const path = `assets/images/${assetName}.png`;
      return preloadImage(path);
    }
    function sprite(assetName) {
      const assets = {
        paddle: { width: 125, height: 25 },
        bubbleLarge: { width: 75, height: 75 },
        bubbleMedium: { width: 30, height: 30 },
        bubbleSmall: { width: 20, height: 20 },
        tinyBubble: { width: 12, height: 12 },
        projectile: { width: 2, height: 6 },
        characterIdle: { width: 75, height: 75 },
        drop_extraLife: { width: 30, height: 30 },
        drop_speedBoost: { width: 30, height: 30 },
        drop_shieldBoost: { width: 30, height: 30 },
        drop_coins: { width: 30, height: 30 },
        drop_weapon: { width: 30, height: 30 },
        drop_slowMotion: { width: 30, height: 30 },
        drop_spreadShot: { width: 30, height: 30 },
        clock: { width: 30, height: 30 }
      };
      return assets[assetName];
    }
    function spriteAnimation(assetName, currentFrame, maxFrames) {
      const frameIndex = (currentFrame % maxFrames) + 1;
      const path = `assets/images/${assetName}_${frameIndex}.png`;
      return preloadImage(path);
    }
    let canvas, ctx, animationFrame;
    let username = "";
    let score = 0, lives = 3, level = 1, combo = 0;
    let xp = 0, xpLevel = 1, bonusGameOpportunities = 0;
    let gameObjects = {
      bubbles: [],
      projectiles: [],
      paddle: null,
      drops: [],
      particles: [],
      explosions: [],
      speechBubbles: []
    };
    gameObjects.companion = null;
    const gravity = 0.2;
    let timeScale = 1.0;
    let speedBoostActive = false, shieldActive = false, weaponBoostActive = false;
    let spreadShotActive = false, slowMotionActive = false;
    let speedBoostTimeout, shieldTimeout, weaponBoostTimeout, spreadShotTimeout, slowMotionTimeout;
    let paddleInvulnerable = false;
    let itemLog = [];
    let shakeTime = 0, shakeIntensity = 0;
    let bgMusicOn = true, sfxOn = true;
    let controlLeft = "a", controlRight = "d", controlShoot = " ";
    let gamePaused = false;
    let achievements = [];
    let customBackdropImg = null;
    let customBackdropIsGif = false;
    const bubbleColors = [];
    for (let i = 0; i < 100; i++) {
      const hue = Math.floor((360 * i) / 100);
      bubbleColors.push(`hsl(${hue}, 80%, 60%)`);
    }
    const regularBackdrops = [
      "assets/images/in-game-backdrop1.png",
      "assets/images/in-game-backdrop2.png",
      "assets/images/in-game-backdrop3.png",
      "assets/images/in-game-backdrop4.png",
      "assets/images/in-game-backdrop5.png",
      "assets/images/in-game-backdrop6.png",
      "assets/images/in-game-backdrop7.png",
      "assets/images/in-game-backdrop8.png",
      "assets/images/in-game-backdrop9.png",
      "assets/images/in-game-backdrop10.png"
    ];
    const specialBackdrops = [
      "assets/images/special-backdrop1.png",
      "assets/images/special-backdrop2.png",
      "assets/images/special-backdrop3.png"
    ];
    const specialLevels = [10, 15, 20, 25];
    regularBackdrops.forEach(src => preloadImage(src));
    specialBackdrops.forEach(src => preloadImage(src));
    let whiteBubbleDialogues = [
      "Hmph, you're so predictable!",
      "Is that all you've got?",
      "Adorable, but futile!",
      "I prefer a real challenge, darling.",
      "Don't get cocky..."
    ];

    // Home Screen Event Listeners
    document.getElementById("usernameInput").addEventListener("input", function (e) {
      const name = e.target.value.trim();
      if (name) {
        document.getElementById("homeProfileUsername").innerText = "Username: " + name;
        document.getElementById("homeProfileLevel").innerText = "Level: 1";
        document.getElementById("homeProfileTopScore").innerText = "Top Score: 0";
      } else {
        document.getElementById("homeProfileUsername").innerText = "Username: Guest";
        document.getElementById("homeProfileLevel").innerText = "Level: 1";
        document.getElementById("homeProfileTopScore").innerText = "Top Score: 0";
      }
    });

    // Canvas and Resizing
    function adjustCanvasSize() {
        canvas = document.getElementById("gameCanvas");
        if (!canvas) return;
        
        const isMobile = window.innerWidth <= 768;
        const mainContainer = document.getElementById("mainContainer");
        
        if (document.fullscreenElement || mainContainer.classList.contains("fullScreen") || isMobile) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (isMobile) {
                // Calculate scale factor based on device size
                const scaleFactor = Math.min(window.innerWidth / 1000, window.innerHeight / 600);
                
                // Scale game objects
                if (gameObjects.paddle) {
                    const originalWidth = gameObjects.paddle.width / (gameObjects.paddle.currentScaleFactor || 1);
                    const originalHeight = gameObjects.paddle.height / (gameObjects.paddle.currentScaleFactor || 1);
                    const originalSpeed = gameObjects.paddle.speed / (gameObjects.paddle.currentScaleFactor || 1);
                    
                    gameObjects.paddle.width = originalWidth * scaleFactor;
                    gameObjects.paddle.height = originalHeight * scaleFactor;
                    gameObjects.paddle.speed = originalSpeed * scaleFactor;
                    gameObjects.paddle.currentScaleFactor = scaleFactor;
                }
                
                // Scale bubbles
                gameObjects.bubbles.forEach(bubble => {
                    const originalRadius = bubble.radius / (bubble.currentScaleFactor || 1);
                    bubble.radius = originalRadius * scaleFactor;
                    bubble.currentScaleFactor = scaleFactor;
                });
                
                // Scale UI elements
                document.querySelectorAll('.backpack-slot').forEach(slot => {
                    slot.style.width = `${40 * scaleFactor}px`;
                    slot.style.height = `${40 * scaleFactor}px`;
                });
            }
        } else {
            const availableWidth = window.innerWidth - 220 - 220 - 20;
            const availableHeight = window.innerHeight - 20;
            const aspect = 1000 / 600;
            let newWidth = availableWidth;
            let newHeight = newWidth / aspect;
            
            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * aspect;
            }
            
            canvas.width = newWidth;
            canvas.height = newHeight;
        }
        
        repositionPlayer();
    }
    function repositionPlayer() {
      if (gameObjects.paddle) {
        const playArea = getPlayArea();
        const floorHeight = canvas.height * 0.05;
        gameObjects.paddle.groundY = playArea.y + playArea.height - floorHeight - gameObjects.paddle.height;
        if (!gameObjects.paddle.isJumping) {
          gameObjects.paddle.y = gameObjects.paddle.groundY;
        }
      }
    }
    window.addEventListener("resize", adjustCanvasSize);
    document.addEventListener("fullscreenchange", adjustCanvasSize);
    adjustCanvasSize();

    // Bonus Game UI
    function updateBonusGameUI() {
      const bonusSpan = document.getElementById("bonusOpportunitiesHome");
      const bonusButton = document.getElementById("playBonusGameButtonHome");
      if (!bonusSpan || !bonusButton) return;
      bonusSpan.innerText = bonusGameOpportunities;
      bonusButton.disabled = (bonusGameOpportunities <= 0);
    }
    function playBonusGame() {
      if (bonusGameOpportunities <= 0) return;
      bonusGameOpportunities--;
      updateBonusGameUI();
      const outcomes = [0.5, 0.75, 1, 1.25, 1.5];
      const multiplier = outcomes[Math.floor(Math.random() * outcomes.length)];
      let bonusMessage = multiplier > 1 ? `Bonus! Coins increased by ${Math.floor((multiplier - 1) * 100)}%!`
                        : multiplier < 1 ? `Penalty! Coins decreased by ${Math.floor((1 - multiplier) * 100)}%!`
                        : `No change in coins.`;
      coinsCollected = Math.floor(coinsCollected * multiplier);
      updateCoinPanel();
      showGameMessage(bonusMessage);
    }

    // Drop Handling
    function activateDrop(drop) {
      if (drop.type === "coins") {
        coinsCollected += drop.value;
        updateCoinPanel();
        showGameMessage(`Collected ${drop.value} coins!`);
      } else if (drop.type === "deathDrop") {
        showGameMessage("Death Drop! Game Over!");
        endGame();
      } else if (drop.type === "freeze") {
        freezeBubbles();
        showGameMessage("Freeze Activated! Bubbles frozen for 7 seconds.");
      } else if (drop.type === "extraLife") {
        if (lives < MAX_LIVES) { lives++; showGameMessage("Extra Life Activated!"); }
        else { showGameMessage("Extra Life wasted, already at max health!"); }
        updateProfileBox();
      } else if (drop.type === "star") {
        shieldActive = true;
        showGameMessage("Star Power Activated! Temporary invincibility!");
        setTimeout(() => { shieldActive = false; }, 15000);
      } else { addToBackpack(drop); }
    }
    function processDropCollision(drop) {
      if (drop.type === "coins" || drop.type === "deathDrop" || drop.type === "extraLife") {
        activateDrop(drop);
      } else if (drop.type === "freeze") {
        freezeBubbles();
        showGameMessage("Freeze Activated! Bubbles frozen for 7 seconds.");
      } else if (drop.type === "star") {
        shieldActive = true;
        showGameMessage("Star Power Activated! Temporary invincibility!");
        setTimeout(() => { shieldActive = false; }, 15000);
      } else if (drop.type === "powerOrb") {
        autoFireActive = true;
        weaponBoostActive = true;
        spreadShotActive = true;
        gameObjects.paddle.powerOrbActive = true;
        showGameMessage("Extra Rare Power Orb Activated!");
        setTimeout(() => {
          autoFireActive = false;
          weaponBoostActive = false;
          spreadShotActive = false;
          gameObjects.paddle.powerOrbActive = false;
        }, 15000);
      } else { addToBackpack(drop); }
    }

    // Leaderboard Functions using Firebase
    function updateLeaderboard() {
      const leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
      const sortedLeaderboard = leaderboard.sort((a, b) => b.score - a.score).slice(0, 3);
      
      // Update home screen leaderboard
      const homeLeaderboardList = document.getElementById("homeLeaderboardList");
      homeLeaderboardList.innerHTML = "";
      sortedLeaderboard.forEach((entry, index) => {
        const div = document.createElement("div");
        div.className = "leaderboard-entry";
        div.innerHTML = `
          <span class="leaderboard-rank">#${index + 1}</span>
          <span class="leaderboard-username">${entry.username}</span>
          <span class="leaderboard-score">${Math.floor(entry.score)}</span>
        `;
        homeLeaderboardList.appendChild(div);
      });

      // Update in-game leaderboard
      const combinedLeaderboard = document.getElementById("combinedLeaderboard");
      combinedLeaderboard.innerHTML = "<h3>Top 3 Players</h3>";
      sortedLeaderboard.forEach((entry, index) => {
        const div = document.createElement("div");
        div.className = "leaderboard-entry";
        div.innerHTML = `
          <span class="leaderboard-rank">#${index + 1}</span>
          <span class="leaderboard-username">${entry.username}</span>
          <span class="leaderboard-score">${Math.floor(entry.score)}</span>
        `;
        combinedLeaderboard.appendChild(div);
      });
    }
    function fetchHomeLeaderboard() {
      firebaseFetchLeaderboard(function(leaderboardData) {
        const listDiv = document.getElementById("homeLeaderboardList");
        listDiv.innerHTML = "";
        leaderboardData.forEach((entry, index) => {
          const entryDiv = document.createElement("div");
          entryDiv.style.fontSize = "10px";
          entryDiv.innerHTML = `<img src="${entry.profilePic || 'assets/images/character1_portrait.gif'}" alt="Profile" style="width:20px;height:20px;border-radius:50%; margin-right:5px;"> ${index + 1}. <strong>${entry.username}</strong> - Score: ${Math.floor(entry.score)}`;
          listDiv.appendChild(entryDiv);
        });
      });
    }
    function populateGameOverLeaderboardFirebase() {
      firebaseFetchLeaderboard(function(leaderboardData) {
        const goList = document.getElementById("gameOverLeaderboard");
        goList.innerHTML = "";
        leaderboardData.forEach(entry => {
          const li = document.createElement("li");
          const walletDisplay = entry.walletAddress ? 
            `(${entry.walletAddress.slice(0, 6)}...${entry.walletAddress.slice(-4)})` : 
            '';
          li.innerHTML = `
            <img src="${entry.profilePic || 'assets/images/character1_portrait.gif'}" 
                 alt="Profile" 
                 style="width:20px;height:20px;border-radius:50%;">
            ${entry.username} ${walletDisplay} | Rounds: ${entry.rounds} | 
            Score: ${Math.floor(entry.score)} | Time: ${entry.timeSurvived}s
          `;
          goList.appendChild(li);
        });
      });
    }
    window.addEventListener("load", fetchHomeLeaderboard);

    // Audio Setup
    const specialSound = new Audio("assets/sounds/special.wav");
    const deathSound = new Audio("assets/sounds/death.wav");
    const bubbleSplitSound = new Audio("assets/sounds/bubbleSplit.wav");
    const audioPop = new Audio("assets/sounds/pop.wav");
    const audioPowerup = new Audio("assets/sounds/powerup.wav");
    const bgMusicPlaylist = [
      "assets/sounds/Backgroundmusic1.wav",
      "assets/sounds/Backgroundmusic2.wav",
      "assets/sounds/Backgroundmusic3.wav",
      "assets/sounds/Backgroundmusic4.wav"
    ];
    const bossMusic = "assets/sounds/bossMusic.wav";
    let currentBgTrack = 0;
    const bgMusic = new Audio(bgMusicPlaylist[currentBgTrack]);
    bgMusic.addEventListener('ended', function () {
      currentBgTrack = (currentBgTrack + 1) % bgMusicPlaylist.length;
      bgMusic.src = bgMusicPlaylist[currentBgTrack];
      bgMusic.play();
    });
    const homeBgMusic = new Audio("assets/sounds/homeBgmusic.wav");
    homeBgMusic.loop = true;
    window.addEventListener("load", function() {
      if (bgMusicOn) { homeBgMusic.play(); bgMusic.pause(); }
    });
    function stopEffectSounds() {
      specialSound.pause(); specialSound.currentTime = 0;
      deathSound.pause(); deathSound.currentTime = 0;
      bubbleSplitSound.pause(); bubbleSplitSound.currentTime = 0;
      audioPop.pause(); audioPop.currentTime = 0;
      audioPowerup.pause(); audioPowerup.currentTime = 0;
    }

    // Moving Walls and Barriers
    let movingWalls = [
      { x: 20, y: 200, width: 100, height: 20, dx: 2 },
      { x: 300, y: 150, width: 80, height: 15, dx: 3 }
    ];
    function updateMovingWalls(playArea) {
      movingWalls.forEach(wall => {
        wall.x += wall.dx * difficultyFactor;
        if (wall.x + wall.width >= playArea.x + playArea.width || wall.x <= playArea.x) {
          wall.dx = -wall.dx;
        }
      });
    }
    function drawMovingWalls(playArea) {
      movingWalls.forEach(wall => {
        ctx.fillStyle = "#880";
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }
    let barriers = [
      { x: 150, yFactor: 0.7, width: 50, height: 10 },
      { x: 400, yFactor: 0.5, width: 60, height: 10 }
    ];
    function drawBarriers(playArea, floorHeight) {
      barriers.forEach(barrier => {
        barrier.y = playArea.y + playArea.height * barrier.yFactor;
        ctx.fillStyle = "#555";
        ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
      });
    }
    function handleBarrierCollisions(bubble, playArea) {
      barriers.forEach(barrier => {
        const barrierRect = {
          x: barrier.x,
          y: playArea.y + playArea.height * barrier.yFactor,
          width: barrier.width,
          height: barrier.height
        };
        if (isCollidingRect({x: bubble.x - bubble.radius, y: bubble.y - bubble.radius, width: bubble.radius * 2, height: bubble.radius * 2}, barrierRect)) {
          bubble.dy = -Math.abs(bubble.dy) * bubble.bounceFactor;
          bubble.y = barrierRect.y - bubble.radius;
        }
      });
    }
    function drawGameBackdrop(playArea) {
      if (customBackdropImg && customBackdropImg.naturalWidth && !customBackdropIsGif) {
        ctx.drawImage(customBackdropImg, 0, 0, canvas.width, canvas.height);
      } else if (!customBackdropImg) {
        let backdropSrc = specialLevels.includes(level)
          ? specialBackdrops[Math.floor(Math.random() * specialBackdrops.length)]
          : regularBackdrops[Math.floor((level - 1) / 3) % regularBackdrops.length];
        const bgImg = preloadImage(backdropSrc);
        if (bgImg.naturalWidth) { ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height); }
        else { ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height); }
      }
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--text-color").trim();
      ctx.lineWidth = 4;
      ctx.strokeRect(playArea.x, playArea.y, playArea.width, playArea.height);
      updateMovingWalls(playArea);
      drawMovingWalls(playArea);
    }
    function drawFloor(playArea) {
      const floorHeight = canvas.height * 0.05;
      const floorImg = preloadImage("assets/images/floor");
      
      // Create gradient for the floor
      const gradient = ctx.createLinearGradient(
        playArea.x,
        playArea.y + playArea.height - floorHeight,
        playArea.x,
        playArea.y + playArea.height
      );
      gradient.addColorStop(0, "#2f3640");  // Dark base
      gradient.addColorStop(0.4, "#353b48"); // Mid tone
      gradient.addColorStop(1, "#2f3640");   // Dark base again
      
      // Draw main floor
      ctx.fillStyle = gradient;
      ctx.fillRect(
        playArea.x,
        playArea.y + playArea.height - floorHeight,
        playArea.width,
        floorHeight
      );
      
      // Add neon glow line on top of floor
      ctx.beginPath();
      ctx.moveTo(playArea.x, playArea.y + playArea.height - floorHeight);
      ctx.lineTo(playArea.x + playArea.width, playArea.y + playArea.height - floorHeight);
      ctx.strokeStyle = "#46fbe3";  // Neon cyan color
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Add subtle grid pattern
      ctx.strokeStyle = "rgba(70, 251, 227, 0.2)";  // Very transparent neon cyan
      ctx.lineWidth = 1;
      const gridSize = floorHeight / 3;
      for (let x = playArea.x; x <= playArea.x + playArea.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, playArea.y + playArea.height - floorHeight);
        ctx.lineTo(x, playArea.y + playArea.height);
        ctx.stroke();
      }
    }

    function drawBoundaries(playArea) {
      // Draw main boundaries
      ctx.fillStyle = "#2f3640";
      ctx.fillRect(playArea.x, playArea.y, playArea.width, 4);
      ctx.fillRect(playArea.x, playArea.y, 4, playArea.height);
      ctx.fillRect(playArea.x + playArea.width - 4, playArea.y, 4, playArea.height);
      
      // Add neon glow effect
      ctx.shadowColor = "#46fbe3";
      ctx.shadowBlur = 10;
      
      // Top boundary neon line
      ctx.beginPath();
      ctx.moveTo(playArea.x, playArea.y);
      ctx.lineTo(playArea.x + playArea.width, playArea.y);
      ctx.strokeStyle = "#46fbe3";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Left boundary neon line
      ctx.beginPath();
      ctx.moveTo(playArea.x, playArea.y);
      ctx.lineTo(playArea.x, playArea.y + playArea.height);
      ctx.stroke();
      
      // Right boundary neon line
      ctx.beginPath();
      ctx.moveTo(playArea.x + playArea.width, playArea.y);
      ctx.lineTo(playArea.x + playArea.width, playArea.y + playArea.height);
      ctx.stroke();
      
      // Reset shadow effect
      ctx.shadowBlur = 0;
    }
    function updateStatsBox() {
      const statsText = document.getElementById("statsText");
      statsText.innerText = "Round: " + level + "   Lives: " + lives + "   Timer: " + roundTimeRemaining + "s";
    }
    function updateProfileBox() {
      document.getElementById("profileUsername").innerText = "Username: " + username;
      document.getElementById("profileLevel").innerText = "Level: " + Math.floor(xpLevel);
      document.getElementById("profileTopScore").innerText = "Top Score: " + Math.floor(score);
      document.getElementById("scoreText").innerText = "Score: " + Math.floor(score);
      document.getElementById("livesText").innerText = "Lives: " + lives;
      document.getElementById("profileWallet").innerText = "Wallet: " + (playerWalletAddress || "Not Connected");

      // Create a new leaderboard section
      const profileBox = document.getElementById("profileBox");
      let leaderboardSection = profileBox.querySelector(".profile-leaderboard");
      if (!leaderboardSection) {
          leaderboardSection = document.createElement("div");
          leaderboardSection.className = "profile-leaderboard info-box hue-border";
          leaderboardSection.innerHTML = `
              <h3>Top 3 Scores</h3>
              <div class="top-scores"></div>
          `;
          profileBox.appendChild(leaderboardSection);
      }

      // Update the top 3 scores
      const topScoresDiv = leaderboardSection.querySelector(".top-scores");
      firebaseFetchLeaderboard(function(leaderboardData) {
          const top3 = leaderboardData.slice(0, 3);
          topScoresDiv.innerHTML = top3.map((entry, index) => `
              <div class="leaderboard-entry">
                  <span class="leaderboard-rank">#${index + 1}</span>
                  <span class="leaderboard-username">${entry.username}</span>
                  <span class="leaderboard-score">${Math.floor(entry.score)}</span>
              </div>
          `).join('');
      });
    }
    function updateCoinPanel() {
      document.getElementById("coinCount").innerText = coinsCollected;
      document.getElementById("coinUsername").innerText = "Player: " + username;
    }
    function isCollidingCircleRect(circle, rect) {
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
      let dx = circle.x - closestX;
      let dy = circle.y - closestY;
      return (dx * dx + dy * dy) <= (circle.radius * circle.radius);
    }
    function isCollidingRect(rect1, rect2) {
      return (rect1.x < rect2.x + rect2.width &&
              rect1.x + rect1.width > rect2.x &&
              rect1.y < rect2.y + rect2.height &&
              rect1.y + rect1.height > rect2.y);
    }
    function updateDifficultyIndicator() {
      if (level < 10) { currentDifficulty = "Easy"; difficultyFactor = 1.0; }
      else if (level < 20) { currentDifficulty = "Medium"; difficultyFactor = 1.1; }
      else { currentDifficulty = "Hard"; difficultyFactor = 1.2; }
      let modifier = (Math.random() * 0.1) - 0.05;
      difficultyFactor += modifier;
    }

    // Randomization Functions
    function generateRandomMovingWalls(playArea) {
      movingWalls = [];
      let count = Math.floor(Math.random() * 3) + 1;
      for (let i = 0; i < count; i++) {
        let width = Math.random() * 100 + 50;
        let height = Math.random() * 20 + 10;
        let x = playArea.x + Math.random() * (playArea.width - width);
        let y = playArea.y + Math.random() * ((playArea.height / 2) - height);
        let dx = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 3 + 1);
        movingWalls.push({ x: x, y: y, width: width, height: height, dx: dx });
      }
    }
    function spawnRandomBubble(playArea) {
        let x = playArea.x + 50 + Math.random() * (playArea.width - 100);
        let y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
        let dx = (Math.random() < 0.5 ? -1 : 1) * (1 + Math.random() * 1.5);
        let dy = -(2 + Math.random() * 2);
        
        // Increased variety of bubble types
        let bubbleType = "normal";
        const specialChance = Math.min(0.4, 0.2 + (level * 0.02)); // Increases with level
        
        if (Math.random() < specialChance) {
            const specialTypes = ["explosive", "teleporting", "shatter", "rainbow", "magnetic"];
            bubbleType = specialTypes[Math.floor(Math.random() * specialTypes.length)];
        }
        
        
        // Create different types of bubbles
        if (bubbleType === "shatter") {
            gameObjects.bubbles.push(new ShatterBubble(x, y, dx, dy));
        } else if (bubbleType === "rainbow") {
            const rainbow = new Bubble(x, y, 15, dx, dy, "medium", "rainbow");
            rainbow.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            gameObjects.bubbles.push(rainbow);
        } else {
            let radius = bubbleType === "normal" ? 
                (15 + Math.random() * 8) : 
                (20);
                
            const bubble = new Bubble(x, y, radius, dx, dy, "small", bubbleType);
            
            // Add special effects based on type
            if (bubbleType === "explosive") {
                bubble.color = "#ff4444";
            } else if (bubbleType === "teleporting") {
                bubble.color = "#44ff44";
            }
            
            gameObjects.bubbles.push(bubble);
        }
    }
    function startNewRound() {
        level++;
        const playArea = getPlayArea();
        gameObjects.bubbles = [];
        
        // Reset round timer
        roundTimeRemaining = 25;
        if (timerInterval) clearInterval(timerInterval);
        
        // Start round timer
        startRoundTimer();
        
        // Generate new platforms for the level
        generateLevelPlatforms(level, playArea);
        
        // Spawn bubbles for the new round
        spawnBubbles(level);
        
        // Update UI
        updateDifficultyIndicator();
        
        // Show round transition
        const message = `Round ${level} - ${currentDifficulty}`;
        showGameMessage(message);
        
        // Add achievement for reaching milestone levels
        if (level % 5 === 0) {
            addAchievement(`Milestone! Reached Level ${level}`);
        }
    }

    // Sprite Classes
    class IdleNoActionSprite {
      constructor(player, assetPrefix = "characterIdle") {
        this.player = player;
        this.assetPrefix = assetPrefix;
        this.frame = 0;
        // Different frame counts for different characters
        this.maxFrames = assetPrefix.includes("2") ? 4 : 3;
        this.frameDelay = 30;
        this.frameDelayCounter = 0;
        const sp = spritePNG(this.assetPrefix + "_1");
        this.width = sp.naturalWidth ? Math.floor(sp.naturalWidth * 1.7) : 85;
        this.height = sp.naturalHeight ? Math.floor(sp.naturalHeight * 1.7) : 85;
      }
      draw() {
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
          this.frame = (this.frame + 1) % this.maxFrames;
          this.frameDelayCounter = 0;
        }
        const img = spriteAnimation(this.assetPrefix, this.frame, this.maxFrames);
        if (img.naturalWidth) { ctx.drawImage(img, this.player.x, this.player.y, this.width, this.height); }
      }
    }
    class IdleShootingSprite {
      constructor(player, assetPrefix = "characterIdleShoot") {
        this.player = player;
        this.assetPrefix = assetPrefix;
        this.frame = 0;
        // Different frame counts for different characters
        this.maxFrames = assetPrefix.includes("2") ? 4 : 6;
        this.frameDelay = 20;
        this.frameDelayCounter = 0;
        const sp = spritePNG(this.assetPrefix + "_1");
        this.width = sp.naturalWidth ? Math.floor(sp.naturalWidth * 1.7) : 85;
        this.height = sp.naturalHeight ? Math.floor(sp.naturalHeight * 1.7) : 85;
      }
      draw() {
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
          this.frame = (this.frame + 1) % this.maxFrames;
          this.frameDelayCounter = 0;
        }
        const img = spriteAnimation(this.assetPrefix, this.frame, this.maxFrames);
        if (img.naturalWidth) { ctx.drawImage(img, this.player.x, this.player.y, this.width, this.height); }
      }
    }
    class RunningSprite {
      constructor(player, assetPrefix = "characterRun") {
        this.player = player;
        this.assetPrefix = assetPrefix;
        this.frame = 0;
        // Different frame counts for different characters
        this.maxFrames = assetPrefix.includes("2") ? 8 : 6;
        this.frameDelay = 5;
        this.frameDelayCounter = 0;
        const sp = spritePNG(this.assetPrefix + "_1");
        this.width = sp.naturalWidth ? Math.floor(sp.naturalWidth * 1.7) : 85;
        this.height = sp.naturalHeight ? Math.floor(sp.naturalHeight * 1.7) : 85;
      }
      draw() {
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
          this.frame = (this.frame + 1) % this.maxFrames;
          this.frameDelayCounter = 0;
        }
        const img = spriteAnimation(this.assetPrefix, this.frame, this.maxFrames);
        if (img.naturalWidth) {
          if (this.player.direction === "left") {
            ctx.save();
            ctx.translate(this.player.x + this.width / 2, this.player.y);
            ctx.scale(-1, 1);
            ctx.drawImage(img, -this.width / 2, 0, this.width, this.height);
            ctx.restore();
          } else { ctx.drawImage(img, this.player.x, this.player.y, this.width, this.height); }
        }
      }
    }
    class RunningShootingSprite {
      constructor(player, assetPrefix = "characterRunShoot") {
        this.player = player;
        this.assetPrefix = assetPrefix;
        this.frame = 0;
        // Different frame counts for different characters
        this.maxFrames = assetPrefix.includes("2") ? 8 : 6;
        this.frameDelay = 5;
        this.frameDelayCounter = 0;
        const sp = spritePNG(this.assetPrefix + "_1");
        this.width = sp.naturalWidth ? Math.floor(sp.naturalWidth * 1.7) : 85;
        this.height = sp.naturalHeight ? Math.floor(sp.naturalHeight * 1.7) : 85;
      }
      draw() {
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
          this.frame = (this.frame + 1) % this.maxFrames;
          this.frameDelayCounter = 0;
        }
        const img = spriteAnimation(this.assetPrefix, this.frame, this.maxFrames);
        if (img.naturalWidth) {
          if (this.player.direction === "left") {
            ctx.save();
            ctx.translate(this.player.x + this.width / 2, this.player.y);
            ctx.scale(-1, 1);
            ctx.drawImage(img, -this.width / 2, 0, this.width, this.height);
            ctx.restore();
          } else { ctx.drawImage(img, this.player.x, this.player.y, this.width, this.height); }
        }
      }
    }
    class Projectile {
      constructor(x, y, angle = 0) {
        this.x = x;
        this.y = y;
        this.frame = 0;
        this.maxFrames = 2;
        const sp = spritePNG("projectileAnim_1");
        this.width = sp.naturalWidth ? sp.naturalWidth * 0.5 : 10;
        this.height = sp.naturalHeight ? sp.naturalHeight * 0.5 : 10;
        this.speed = 6;
        this.angle = angle;
      }
      draw() {
        const img = spriteAnimation("projectileAnim", this.frame, this.maxFrames);
        if (img.naturalWidth) { ctx.drawImage(img, this.x, this.y, this.width, this.height); }
      }
      update(dt) {
        this.frame = (this.frame + 1) % this.maxFrames;
        this.x += Math.sin(this.angle) * this.speed * dt;
        this.y -= Math.cos(this.angle) * this.speed * dt;
      }
    }
    class GrappleLaserProjectile {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 100;
        this.speed = 8;
      }
      draw() {
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
      update(dt) { this.y -= this.speed * dt; }
    }
    class Bubble {
      constructor(x, y, radius, dx, dy, size, type = "normal") {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.dx = dx * difficultyFactor;
        this.dy = dy * difficultyFactor;
        this.size = size;
        this.type = type;
        this.frame = 0;
        this.maxFrames = 8;
        this.frameDelay = 5;
        this.frameDelayCounter = 0;
        this.gravityModifier = 0.8 + Math.random() * 0.4;
        this.bounceFactor = Math.max(0.85 - (level * 0.008 * difficultyFactor), 0.65);
        this.color = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
        this.animationState = "idle";
        
        // Special properties for different types
        if (type === "teleporting") {
            this.teleportsLeft = 3;
        } else if (type === "magnetic") {
            this.magneticRange = 100;
            this.magneticForce = 0.5;
            this.color = "#8844ff";
        }
        
        // Animation properties
        this.scaleAnim = 1;
        this.scaleDir = 1;
        this.rotationAngle = 0;
        this.wobbleOffset = Math.random() * Math.PI * 2;
      }

      update(dt) {
        if (freezeActive) return;
        
        // Update animation state
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
            this.frame = (this.frame + 1) % this.maxFrames;
            this.frameDelayCounter = 0;
        }

        // Update wobble animation
        this.scaleAnim += 0.01 * this.scaleDir;
        if (this.scaleAnim > 1.1) this.scaleDir = -1;
        if (this.scaleAnim < 0.9) this.scaleDir = 1;
        
        // Update rotation
        this.rotationAngle = Math.sin(Date.now() * 0.002 + this.wobbleOffset) * 0.1;

        // Apply magnetic effect if applicable
        if (this.type === "magnetic") {
            gameObjects.bubbles.forEach(bubble => {
                if (bubble !== this && bubble.type !== "magnetic") {
                    const dx = this.x - bubble.x;
                    const dy = this.y - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.magneticRange) {
                        const force = (1 - distance / this.magneticRange) * this.magneticForce;
                        bubble.dx += (dx / distance) * force;
                        bubble.dy += (dy / distance) * force;
                    }
                }
            });
        }

        const levelFactor = 1 + (level - 1) * SPEED_INCREASE_PER_LEVEL * difficultyFactor;
        this.dy += gravity * this.gravityModifier * dt * levelFactor;
        this.x += this.dx * dt * levelFactor;
        this.y += this.dy * dt;

        // Add jitter based on level
        let jitterProbability = (level >= 10) ? 0.1 : 0.03;
        if (Math.random() < jitterProbability) {
            this.dx += (Math.random() - 0.5) * 2 * difficultyFactor;
            this.dy += (Math.random() - 0.5) * 2 * difficultyFactor;
        }

        // Handle collisions
        this.handleCollisions(getPlayArea());
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotationAngle);
        ctx.scale(this.scaleAnim, this.scaleAnim);

        // Draw magnetic field effect for magnetic bubbles
        if (this.type === "magnetic") {
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.magneticRange);
            gradient.addColorStop(0, 'rgba(136, 68, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(136, 68, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, this.magneticRange, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw bubble with animation effects
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        // Create gradient for 3D effect
        const gradient = ctx.createRadialGradient(
            -this.radius * 0.3, -this.radius * 0.3, 0,
            0, 0, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.2, this.getTypeColor());
        gradient.addColorStop(1, this.getTypeColor(0.7));
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = this.getTypeColor();
        ctx.shadowBlur = 10;
        ctx.fill();
        
        // Add shine effect
        ctx.beginPath();
        ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();

        // Add magnetic symbol for magnetic bubbles
        if (this.type === "magnetic") {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.5, Math.PI * 0.25, Math.PI * 1.75, true);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.radius * 0.3, -this.radius * 0.3);
            ctx.lineTo(this.radius * 0.5, 0);
            ctx.lineTo(this.radius * 0.3, this.radius * 0.3);
            ctx.stroke();
        }
        
        ctx.restore();
      }

      getTypeColor(alpha = 1) {
        switch(this.type) {
          case "explosive": return `rgba(255, 0, 0, ${alpha})`;
          case "teleporting": return `rgba(255, 255, 255, ${alpha})`;
          case "shatterChild": return `rgba(255, 192, 203, ${alpha})`;
          default: return this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
        }
      }

      handleCollisions(playArea) {
        if (this.x + this.radius >= playArea.x + playArea.width) {
          this.dx = -Math.abs(this.dx * this.bounceFactor);
          this.x = playArea.x + playArea.width - this.radius;
          this.animationState = "bouncing";
        } else if (this.x - this.radius <= playArea.x) {
          this.dx = Math.abs(this.dx * this.bounceFactor);
          this.x = playArea.x + this.radius;
          this.animationState = "bouncing";
        }

        if (this.y - this.radius <= playArea.y) {
          this.dy = -this.dy * this.bounceFactor;
          this.y = playArea.y + this.radius;
          this.animationState = "bouncing";
        }

        const floorY = playArea.y + playArea.height;
        if (this.y + this.radius >= floorY) {
          this.dy = -(12 + level * 0.5) * (1 + (level - 1) * SPEED_INCREASE_PER_LEVEL * difficultyFactor);
          this.dx *= 0.98;
          this.y = floorY - this.radius;
          this.animationState = "bouncing";
        }
      }
    }
    class ShatterBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 25, dx, dy, "shatter");
        this.health = 1;
      }
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#ff69b4";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.restore();
      }
    }
    class FrozenBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 30, dx, dy, "frozen");
        this.color = "#66ccff";
        this.bounceFactor = Math.max(0.85 - (level * 0.008 * difficultyFactor), 0.7);
      }
      update(dt) {
        if (freezeActive) return;
        this.dy += (gravity * 0.5 * this.gravityModifier * dt);
        super.update(dt);
      }
    }
    class HugeBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 80, dx, dy, "boss");
        this.health = BOSS_HEALTH_BASE + level;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
      }
      draw() {
        const img = spritePNG("goldenBubble");
        if (img.naturalWidth) { ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); }
        else {
          ctx.beginPath();
          ctx.fillStyle = "#aaf";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
        if (Date.now() - this.lastHitTime < 150) {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      update(dt) {
        if (level >= 12 && Math.random() < 0.06 * difficultyFactor) {
          this.dx += (Math.random() - 0.5) * 3 * difficultyFactor;
          this.dy += (Math.random() - 0.5) * 3 * difficultyFactor;
        }
        super.update(dt);
      }
    }
    class GoldenBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 60, dx, dy, "golden");
        this.health = BOSS_HEALTH_BASE * 2 + level * 2;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
      }
      draw() {
        const img = spritePNG("goldenBubble");
        if (img.naturalWidth) { ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); }
        else {
          ctx.beginPath();
          ctx.fillStyle = "#ff0";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
        if (Date.now() - this.lastHitTime < 150) {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      update(dt) { super.update(dt); }
    }
    class BossBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 80, dx, dy, "boss");
        this.health = BOSS_HEALTH_BASE * 3 + level * 3;
        this.maxHealth = this.health;
        this.gravityModifier = 1.0;
        this.phase = 1;
        this.lastHitTime = 0;
      }
      draw() {
        const img = spritePNG("bubbleBoss");
        if (img.naturalWidth) {
          ctx.save();
          const scale = 1 + Math.sin(Date.now() * 0.005) * 0.05;
          ctx.translate(this.x - this.radius * scale, this.y - this.radius * scale);
          ctx.scale(scale, scale);
          ctx.drawImage(img, 0, 0, this.radius * 2, this.radius * 2);
          ctx.restore();
        } else {
          ctx.beginPath();
          ctx.fillStyle = "#f00";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
        if (Date.now() - this.lastHitTime < 150) {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      update(dt) {
        if (gameObjects.paddle) {
          let paddleCenter = gameObjects.paddle.x + gameObjects.paddle.width / 2;
          if (this.x < paddleCenter) { this.dx += 0.05 * difficultyFactor; }
          else { this.dx -= 0.05 * difficultyFactor; }
        }
        super.update(dt);
      }
    }

    // New boss types
    class SplitBossBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 70, dx, dy, "boss");
        this.health = BOSS_HEALTH_BASE * 2 + level * 2;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
        this.splitCount = 0;
        this.maxSplits = 2;
      }

      draw() {
        const img = spritePNG("bubbleBoss");
        if (img.naturalWidth) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(Date.now() * 0.002);
          ctx.drawImage(img, -this.radius, -this.radius, this.radius * 2, this.radius * 2);
          ctx.restore();
        } else {
          ctx.beginPath();
          ctx.fillStyle = "#800080";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        this.drawHealthBar();
      }

      drawHealthBar() {
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
      }

      update(dt) {
        if (this.health < this.maxHealth / 2 && this.splitCount < this.maxSplits) {
          this.split();
        }
        super.update(dt);
      }

      split() {
        this.splitCount++;
        const angle1 = -Math.PI / 4;
        const angle2 = Math.PI / 4;
        const speed = 3 * difficultyFactor;

        for (let angle of [angle1, angle2]) {
          const dx = Math.cos(angle) * speed;
          const dy = Math.sin(angle) * speed;
          const newBubble = new MiniBossBubble(this.x, this.y, dx, dy);
          newBubble.health = Math.ceil(this.health / 3);
          gameObjects.bubbles.push(newBubble);
        }
      }
    }

    class TeleportingBossBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 75, dx, dy, "boss");
        this.health = BOSS_HEALTH_BASE * 2.5 + level * 2;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
        this.teleportCooldown = 3000;
        this.lastTeleport = Date.now();
      }

      draw() {
        const img = spritePNG("bubbleBoss");
        if (img.naturalWidth) {
          ctx.save();
          const fadeEffect = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
          ctx.globalAlpha = fadeEffect;
          ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
          ctx.restore();
        } else {
          ctx.beginPath();
          ctx.fillStyle = "#4B0082";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        this.drawHealthBar();
      }

      drawHealthBar() {
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
      }

      update(dt) {
        if (Date.now() - this.lastTeleport > this.teleportCooldown) {
          this.teleport();
        }
        super.update(dt);
      }

      teleport() {
        const playArea = getPlayArea();
        createParticles(this.x, this.y, "#4B0082");
        this.x = playArea.x + 50 + Math.random() * (playArea.width - 100);
        this.y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
        this.dx = (Math.random() - 0.5) * 4 * difficultyFactor;
        this.dy = (Math.random() - 0.5) * 4 * difficultyFactor;
        createParticles(this.x, this.y, "#4B0082");
        this.lastTeleport = Date.now();
        
        // Spawn mini bubbles after teleporting
        for (let i = 0; i < 3; i++) {
          const angle = (Math.PI * 2 * i) / 3;
          const speed = 2 * difficultyFactor;
          const dx = Math.cos(angle) * speed;
          const dy = Math.sin(angle) * speed;
          gameObjects.bubbles.push(new Bubble(this.x, this.y, 20, dx, dy, "small"));
        }
      }
    }

    class LaserBossBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 85, dx, dy, "boss");
        this.health = BOSS_HEALTH_BASE * 3 + level * 2;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
        this.laserCooldown = 4000;
        this.lastLaser = Date.now();
        this.isChargingLaser = false;
        this.chargeStartTime = 0;
        this.chargeDuration = 1000;
      }

      draw() {
        const img = spritePNG("bubbleBoss");
        if (img.naturalWidth) {
          ctx.save();
          if (this.isChargingLaser) {
            const chargeProgress = (Date.now() - this.chargeStartTime) / this.chargeDuration;
            const pulseEffect = Math.sin(Date.now() * 0.01) * 0.2 + 1;
            ctx.scale(pulseEffect, pulseEffect);
          }
          ctx.drawImage(img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
          ctx.restore();
        } else {
          ctx.beginPath();
          ctx.fillStyle = this.isChargingLaser ? "#ff0000" : "#FF4500";
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        }
        this.drawHealthBar();
        
        if (this.isChargingLaser) {
          this.drawLaserWarning();
        }
      }

      drawHealthBar() {
        if (this.health > 0) {
          let barWidth = this.radius * 2, barHeight = 5, healthRatio = this.health / this.maxHealth;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, barWidth * healthRatio, barHeight);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 10, barWidth, barHeight);
        }
      }

      drawLaserWarning() {
        const chargeProgress = (Date.now() - this.chargeStartTime) / this.chargeDuration;
        const warningAlpha = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
        
        ctx.save();
        ctx.strokeStyle = `rgba(255, 0, 0, ${warningAlpha})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, canvas.height);
        ctx.stroke();
        ctx.restore();
      }

      update(dt) {
        const currentTime = Date.now();
        
        if (!this.isChargingLaser && currentTime - this.lastLaser > this.laserCooldown) {
          this.startChargingLaser();
        }
        
        if (this.isChargingLaser && currentTime - this.chargeStartTime > this.chargeDuration) {
          this.fireLaser();
        }
        
        // Slower movement while charging
        const movementFactor = this.isChargingLaser ? 0.5 : 1;
        this.x += this.dx * dt * movementFactor;
        this.y += this.dy * dt * movementFactor;
        
        // Bounce off walls
        const playArea = getPlayArea();
        if (this.x - this.radius < playArea.x || this.x + this.radius > playArea.x + playArea.width) {
          this.dx *= -1;
        }
        if (this.y - this.radius < playArea.y || this.y + this.radius > playArea.y + playArea.height) {
          this.dy *= -1;
        }
      }

      startChargingLaser() {
        this.isChargingLaser = true;
        this.chargeStartTime = Date.now();
        if (sfxOn) {
          const chargeSound = new Audio("assets/sounds/laser_charge.mp3");
          chargeSound.volume = 0.3;
          chargeSound.play();
        }
      }

      fireLaser() {
        this.isChargingLaser = false;
        this.lastLaser = Date.now();
        
        // Create laser beam effect
        const laserBeam = {
          x: this.x,
          y: this.y,
          width: 20,
          height: canvas.height - this.y,
          damage: 1,
          duration: 500,
          startTime: Date.now()
        };
        
        if (!gameObjects.laserBeams) {
          gameObjects.laserBeams = [];
        }
        gameObjects.laserBeams.push(laserBeam);
        
        if (sfxOn) {
          const laserSound = new Audio("assets/sounds/laser_fire.mp3");
          laserSound.volume = 0.3;
          laserSound.play();
        }
      }
    }

    // Boss selection system
    const BOSS_TYPES = [
      { type: BossBubble, weight: 1 },
      { type: SplitBossBubble, weight: 1 },
      { type: TeleportingBossBubble, weight: 1 },
      { type: LaserBossBubble, weight: 1 }
    ];

    function selectRandomBossType() {
      const totalWeight = BOSS_TYPES.reduce((sum, boss) => sum + boss.weight, 0);
      let random = Math.random() * totalWeight;
      
      for (const boss of BOSS_TYPES) {
        random -= boss.weight;
        if (random <= 0) {
          return boss.type;
        }
      }
      return BossBubble; // Fallback to default boss
    }

    class MiniBossBubble extends Bubble {
      constructor(x, y, dx, dy) {
        super(x, y, 30, dx, dy, "miniBoss");
        this.health = 2;
        this.maxHealth = this.health;
        this.lastHitTime = 0;
      }
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#800080";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
      update(dt) { super.update(dt); }
    }
    class SpeechBubble {
      constructor(x, y, text) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.duration = 3000;
        this.startTime = Date.now();
      }
      draw() {
        if (Date.now() - this.startTime > this.duration) return;
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x - 10, this.y - 40, 150, 30);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(this.x - 10, this.y - 40, 150, 30);
        ctx.fillStyle = "#000";
        ctx.font = "16px 'Sawarabi Mincho'";
        ctx.fillText(this.text, this.x, this.y - 20);
      }
    }
    function splitBubble(bubble, index) {
      gameObjects.bubbles.splice(index, 1);
      if (bubble.type === "shatter") {
        for (let i = 0; i < 4; i++) {
          let angle = (Math.PI / 2) * i + (Math.random() * 0.2 - 0.1);
          let newDx = Math.cos(angle) * 3 * difficultyFactor;
          let newDy = Math.sin(angle) * 3 * difficultyFactor;
          gameObjects.bubbles.push(new Bubble(bubble.x, bubble.y, bubble.radius * 0.5, newDx, newDy, "tiny", "shatterChild"));
        }
        return;
      }
      const mapping = {
        "huge": { newSize: "large", newRadius: 50, splits: 2 },
        "large": { newSize: "medium", newRadius: 30, splits: 2 },
        "medium": { newSize: "small", newRadius: 20, splits: 2 },
        "small": { newSize: "tiny", newRadius: 12, splits: 2 },
        "tiny": { splits: 0 }
      };
      if (!mapping[bubble.size] || mapping[bubble.size].splits === 0) return;
      const { newSize, newRadius, splits } = mapping[bubble.size];
      const angleSpread = Math.PI / 2;
      const baseAngle = -Math.PI / 2;
      for (let i = 0; i < splits; i++) {
        let angle = baseAngle + (i - (splits - 1) / 2) * (angleSpread / (splits - 1));
        let newDx = Math.cos(angle) * 3 * difficultyFactor;
        let newDy = Math.sin(angle) * 3 * difficultyFactor;
        gameObjects.bubbles.push(new Bubble(bubble.x, bubble.y, newRadius, newDx, newDy, newSize));
      }
    }
    function freezeBubbles() {
      freezeActive = true;
      setTimeout(() => { freezeActive = false; }, 7000);
    }
    function restartGame() {
      // Stop any ongoing game processes
      stopEffectSounds();
      clearInterval(timerInterval);
      cancelAnimationFrame(animationFrame);
      stopGameOverAnimation();
      
      // Reset game state
      gamePaused = false;
      score = 0;
      lives = 3;
      level = 1;
      combo = 0;
      roundTimeRemaining = 25;
      difficultyFactor = 1.0;
      currentDifficulty = "Easy";
      backpackInventory = {};
      coinsCollected = 0;
      xp = 0;
      
      // Reset power-ups and effects
      speedBoostActive = false;
      shieldActive = false;
      weaponBoostActive = false;
      spreadShotActive = false;
      slowMotionActive = false;
      paddleInvulnerable = false;
      timeScale = 1.0;
      
      // Clear all timeouts and intervals
      clearTimeout(speedBoostTimeout);
      clearTimeout(shieldTimeout);
      clearTimeout(weaponBoostTimeout);
      clearTimeout(spreadShotTimeout);
      clearTimeout(slowMotionTimeout);
      clearInterval(autoFireInterval);
      autoFireActive = false;
      
      // Reset game objects
      gameObjects = {
          bubbles: [],
          projectiles: [],
          drops: [],
          particles: [],
          explosions: [],
          speechBubbles: [],
          paddle: null,
          companion: null
      };
      
      // Hide all game screens
      document.getElementById('gameOverScreen').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'none';
      document.getElementById('mainContainer').style.display = 'none';
      
      // Show restart cutscene
      updateGameState(GameState.CUTSCENE);
      showRestartCutscene(async () => {
          // Show game canvas
          document.getElementById('gameCanvas').style.display = 'block';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Initialize new game with current character
          await initGame(currentCharacterSelection);
          
          // Reset music
          if (bgMusic) {
              bgMusic.currentTime = 0;
              bgMusic.volume = parseFloat(document.getElementById('bgVolume').value || 0.5);
              if (bgMusicOn) bgMusic.play();
          }
          
          // Start round 1
          level = 1;
          roundTimeRemaining = 25;
          startRoundTimer();
          
          // Spawn initial bubbles for round 1
          const playArea = getPlayArea();
          spawnBubbles(1); // Explicitly pass level 1
          
          // Update all UI elements
          updateProfileBox();
          updateDifficultyIndicator();
          updateCoinPanel();
          updateBackpackUI();
          updateBonusGameUI();
          updateAchievements();
          
          // Start game loop
          updateGameState(GameState.PLAYING);
          lastFrameTime = performance.now();
          gameLoop();
      });
    }
    function endGame() {
      stopEffectSounds();
      clearInterval(timerInterval);
      cancelAnimationFrame(animationFrame);
      document.getElementById("gameCanvas").style.display = "none";
      document.getElementById("gameOverScreen").style.display = "block";
      startGameOverAnimation();
      document.getElementById("finalScore").innerText =
        `Player: ${username} | Score: ${score} | Rounds: ${level} | Time Used: ${25 - roundTimeRemaining}s | XP: ${xp} | Level: ${xpLevel}`;
      document.getElementById('scoreConfirmModal').style.display = 'flex';
      document.getElementById('confirmScoreSubmit').onclick = () => {
        firebaseSubmitScore();
        document.getElementById('scoreConfirmModal').style.display = 'none';
      };
      document.getElementById('cancelScoreSubmit').onclick = () => {
        document.getElementById('scoreConfirmModal').style.display = 'none';
      };
      fetchHomeLeaderboard();
      populateGameOverLeaderboardFirebase();
      if (autoFireActive) { clearInterval(autoFireInterval); autoFireActive = false; }
      updateGameState(GameState.GAME_OVER);
    }
    function addAchievement(message) {
      achievements.push(message);
      updateAchievements();
      setTimeout(() => { achievements.shift(); updateAchievements(); }, 5000);
    }
    function updateAchievements() {
      const achDiv = document.getElementById("achievementLog");
      achDiv.innerHTML = "<h4>Achievements</h4>";
      achievements.forEach(msg => {
        const p = document.createElement("p");
        p.innerText = msg;
        achDiv.appendChild(p);
      });
    }
    // Add this before the showCutscene function
    const gameAssets = {
        images: [
            'assets/images/custom-background.png',
            'assets/images/canvas-background.png',
            'assets/images/character1_portrait.gif',
            'assets/images/character2_portrait.gif',
            'assets/images/character3_portrait.gif',
            'assets/images/character4_portrait.gif',
            'assets/images/character5_portrait.gif',
            'assets/images/floor.png',
            'assets/images/start_cutscene.png',
            'assets/images/boss_cutscene.png',
            'assets/images/characterIdle_1.png',
            'assets/images/characterIdle_2.png',
            'assets/images/characterIdle_3.png',
            'assets/images/characterRun_1.png',
            'assets/images/characterRun_2.png',
            'assets/images/characterRun_3.png',
            'assets/images/characterRun_4.png',
            'assets/images/characterRun_5.png',
            'assets/images/characterRun_6.png',
            'assets/images/projectileAnim_1.png',
            'assets/images/projectileAnim_2.png'
        ],
        sounds: [
            'assets/sounds/pop.wav',
            'assets/sounds/powerup.wav',
            'assets/sounds/special.wav',
            'assets/sounds/death.wav',
            'assets/sounds/bubbleSplit.wav',
            'assets/sounds/Backgroundmusic1.wav',
            'assets/sounds/Backgroundmusic2.wav',
            'assets/sounds/Backgroundmusic3.wav',
            'assets/sounds/Backgroundmusic4.wav',
            'assets/sounds/bossMusic.wav',
            'assets/sounds/homeBgmusic.wav'
        ]
    };

    // Add loading progress tracking
    let totalAssetsLoaded = 0;
    let totalAssetsToLoad = 0;

    async function preloadAssets() {
        const loadingPromises = [];
        totalAssetsToLoad = gameAssets.images.length + gameAssets.sounds.length;
        totalAssetsLoaded = 0;
        
        function updateLoadingProgress() {
            const percentage = Math.floor((totalAssetsLoaded / totalAssetsToLoad) * 100);
            const loadingDiv = document.querySelector('.loading-progress');
            if (loadingDiv) {
                loadingDiv.innerHTML = `Loading... ${percentage}%`;
            }
        }

        // Preload images
        gameAssets.images.forEach(src => {
            loadingPromises.push(new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    assetCache[src] = img;
                    totalAssetsLoaded++;
                    updateLoadingProgress();
                    resolve();
                };
                img.onerror = () => {
                    console.warn(`Failed to load image: ${src}`);
                    totalAssetsLoaded++;
                    updateLoadingProgress();
                    resolve(); // Resolve anyway to not block the game
                };
                img.src = src;
            }));
        });

        // Preload sounds
        gameAssets.sounds.forEach(src => {
            loadingPromises.push(new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.oncanplaythrough = () => {
                    totalAssetsLoaded++;
                    updateLoadingProgress();
                    resolve();
                };
                audio.onerror = () => {
                    console.warn(`Failed to load sound: ${src}`);
                    totalAssetsLoaded++;
                    updateLoadingProgress();
                    resolve(); // Resolve anyway to not block the game
                };
                audio.src = src;
            }));
        });

        return Promise.all(loadingPromises);
    }

    // Update the showCutscene function
    async function showCutscene(type, callback) {
      const cutsceneDiv = document.getElementById('cutscene');
      const cutsceneContent = document.getElementById('cutsceneContent');
      const skipButton = document.getElementById('skipCutscene');
        
      cutsceneDiv.style.display = 'flex';
      cutsceneContent.innerHTML = '';
      skipButton.style.display = 'none';
        
      // Add loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.innerHTML = `
          <div style="text-align: center; color: var(--accent-color);">
              <h2 style="font-family: 'Sawarabi Mincho', serif; font-size: 24px;">Loading Scene...</h2>
              <div class="loading-progress" style="margin: 20px 0; font-size: 18px;">Loading... 0%</div>
          </div>
      `;
      cutsceneContent.appendChild(loadingDiv);

      try {
          await preloadAssets();
          await new Promise(resolve => setTimeout(resolve, 500));
          
          let slides = [];
          if (type === 'start') {
              slides = [
                  { 
                      img: "assets/images/start_cutscene1.jpeg", 
                      text: "A mysterious bubble shimmers, whispering dark sounds of the end....",
                      style: "grid-column: 1 / 3; grid-row: 1 / 2;"
                  },
                  { 
                      img: "assets/images/start_cutscene2.jpeg", 
                      text: "The Omegas have found the sacred planet.",
                      style: "grid-column: 1 / 2; grid-row: 2 / 3;"
                  },
                  { 
                      img: "assets/images/start_cutscene3.jpeg", 
                      text: "Neon was a hybrid city, far in the universe, A hideout from the Solar Wars.",
                      style: "grid-column: 2 / 3; grid-row: 2 / 3;"
                  },
                  { 
                      img: "assets/images/start_cutscene4.jpeg", 
                      text: "Yumi knows Why they are here, The Power Orbs!",
                      style: "grid-column: 1 / 2; grid-row: 3 / 4;"
                  },
                  { 
                      img: "assets/images/start_cutscene5.jpeg", 
                      text: "The adventure begins... Yumi's destiny starts!",
                      style: "grid-column: 2 / 3; grid-row: 3 / 4;"
                  }
              ];
          } else if (type === 'boss') {
              slides = [
                  { 
                      img: "assets/images/boss_cutscene1.jpeg", 
                      text: "Deep within the abyss, a sinister force awakens...",
                      style: "grid-column: 1 / 3; grid-row: 1 / 2;"
                  },
                  { 
                      img: "assets/images/boss_cutscene2.jpeg", 
                      text: "A dark bubble looms, its presence chilling the soul.",
                      style: "grid-column: 1 / 2; grid-row: 2 / 3;"
                  },
                  { 
                      img: "assets/images/boss_cutscene3.jpeg", 
                      text: "Yumi's heart pounds as she faces the ominous threat.",
                      style: "grid-column: 2 / 3; grid-row: 2 / 3;"
                  },
                  { 
                      img: "assets/images/boss_cutscene4.jpeg", 
                      text: "Clashing wills spark an epic showdown in the twilight.",
                      style: "grid-column: 1 / 2; grid-row: 3 / 4;"
                  },
                  { 
                      img: "assets/images/boss_cutscene5.jpeg", 
                      text: "Brace yourself! The fate of the world hangs by a thread!",
                      style: "grid-column: 2 / 3; grid-row: 3 / 4;"
                  }
              ];
          }

          let collageHTML = '<div class="cutscene-collage">';
          slides.forEach((slide, index) => {
              collageHTML += `
                  <div class="slide" style="${slide.style}" data-index="${index}">
                      <img src="${slide.img}" alt="Cutscene Image">
                      <div class="dialog">
                          <span class="dialog-text">${slide.text}</span>
                      </div>
                  </div>
              `;
          });
          collageHTML += '</div>';
          
          // Add manga-style page number
          collageHTML += `
              <div class="manga-page-number">
                  <span>${type === 'start' ? 'Chapter 1' : 'Boss Battle'}</span>
              </div>
          `;
          
          cutsceneContent.innerHTML = collageHTML;

          // Show skip button after a delay
          setTimeout(() => {
              skipButton.style.display = 'block';
              skipButton.textContent = '≫ Skip Scene';
          }, 2000);

          // Set up skip button functionality
          skipButton.onclick = () => {
              cutsceneDiv.style.display = 'none';
              if (callback) callback();
          };

          // Auto-proceed after a longer delay if not skipped
          const autoProceedTimeout = setTimeout(() => {
              if (cutsceneDiv.style.display !== 'none') {
                  cutsceneDiv.style.display = 'none';
                  if (callback) callback();
              }
          }, 15000); // 15 seconds auto-proceed

          // Clean up timeout if skipped
          skipButton.addEventListener('click', () => {
              clearTimeout(autoProceedTimeout);
          }, { once: true });

      } catch (error) {
          console.error('Error loading cutscene:', error);
          cutsceneContent.innerHTML = '<div class="error-message">Failed to load cutscene. Please try again.</div>';
      }
    }

    async function showRestartCutscene(callback) {
      const cutsceneDiv = document.getElementById('cutscene');
      const cutsceneContent = document.getElementById('cutsceneContent');
      const skipButton = document.getElementById('skipCutscene');
        
      cutsceneDiv.style.display = 'flex';
      cutsceneContent.innerHTML = '';
      skipButton.style.display = 'none';
        
      // Add loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.innerHTML = `
          <div style="text-align: center; color: var(--accent-color);">
              <h2 style="font-family: 'Sawarabi Mincho', serif; font-size: 24px;">Restarting Journey...</h2>
              <div class="loading-progress" style="margin: 20px 0; font-size: 18px;">Loading... 0%</div>
          </div>
      `;
      cutsceneContent.appendChild(loadingDiv);

      try {
          await preloadAssets();
          await new Promise(resolve => setTimeout(resolve, 500));
          
          const slides = [
              { 
                  img: "assets/images/restart_cutscene1.jpeg", 
                  text: "Time flows backward, memories fade into mist...",
                  style: "grid-column: 1 / 3; grid-row: 1 / 2;"
              },
              { 
                  img: "assets/images/restart_cutscene2.jpeg", 
                  text: "The universe grants Yumi another chance.",
                  style: "grid-column: 1 / 2; grid-row: 2 / 3;"
              },
              { 
                  img: "assets/images/restart_cutscene3.jpeg", 
                  text: "This time, the story might unfold differently...",
                  style: "grid-column: 2 / 3; grid-row: 2 / 3;"
              },
              { 
                  img: "assets/images/restart_cutscene4.jpeg", 
                  text: "Armed with knowledge from the past...",
                  style: "grid-column: 1 / 2; grid-row: 3 / 4;"
              },
              { 
                  img: "assets/images/restart_cutscene5.jpeg", 
                  text: "A new beginning awaits!",
                  style: "grid-column: 2 / 3; grid-row: 3 / 4;"
              }
          ];

          let collageHTML = '<div class="cutscene-collage">';
          slides.forEach((slide, index) => {
              collageHTML += `
                  <div class="slide" style="${slide.style}" data-index="${index}">
                      <img src="${slide.img}" alt="Cutscene Image">
                      <div class="dialog">
                          <span class="dialog-text">${slide.text}</span>
                      </div>
                  </div>
              `;
          });
          collageHTML += '</div>';
          
          // Add manga-style page number
          collageHTML += `
              <div class="manga-page-number">
                  <span>New Chapter</span>
              </div>
          `;
          
          cutsceneContent.innerHTML = collageHTML;

          // Show skip button after a delay
          setTimeout(() => {
              skipButton.style.display = 'block';
              skipButton.textContent = '≫ Begin Anew';
          }, 2000);

          // Set up skip button functionality
          skipButton.onclick = () => {
              cutsceneDiv.style.display = 'none';
              if (callback) callback();
          };

          // Auto-proceed after a longer delay if not skipped
          const autoProceedTimeout = setTimeout(() => {
              if (cutsceneDiv.style.display !== 'none') {
                  cutsceneDiv.style.display = 'none';
                  if (callback) callback();
              }
          }, 12000); // 12 seconds auto-proceed

          // Clean up timeout if skipped
          skipButton.addEventListener('click', () => {
              clearTimeout(autoProceedTimeout);
          }, { once: true });

      } catch (error) {
          console.error('Error loading restart cutscene:', error);
          cutsceneContent.innerHTML = '<div class="error-message">Failed to load cutscene. Please try again.</div>';
          if (callback) callback();
      }
    }

    let rightPressed = false, leftPressed = false;
    let lastFrameTime = performance.now();
    function startRoundTimer() {
      roundTimeRemaining = 25;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!gamePaused && currentState === GameState.PLAYING) {
          roundTimeRemaining--;
          updateStatsBox();
          if (roundTimeRemaining <= 0) {
            showGameMessage("Time's up! You failed to complete the round.");
            clearInterval(timerInterval);
            endGame();
          }
        }
      }, 1000);
    }
    function spawnDrop(x, y) {
      let dropOptions = [
        { type: "extraLife", weight: 3 },
        { type: "speedBoost", weight: 3 },
        { type: "shieldBoost", weight: 3 },
        { type: "coins", weight: 3 },
        { type: "weapon", weight: 3 },
        { type: "slowMotion", weight: 3 },
        { type: "spreadShot", weight: 3 },
        { type: "clock", weight: 3 },
        { type: "ultimateBoost", weight: 3 },
        { type: "laserFire", weight: 3 },
        { type: "star", weight: 1 },
        { type: "deathDrop", weight: 1 },
        { type: "freeze", weight: 1 },
        { type: "powerOrb", weight: 1 }
      ];
      let totalWeight = dropOptions.reduce((sum, option) => sum + option.weight, 0);
      let rand = Math.random() * totalWeight;
      let chosen = dropOptions.find(option => { rand -= option.weight; return rand < 0; });
      let value = (chosen.type === "coins") ? Math.floor(Math.random() * 50 * difficultyFactor) + 1 : 0;
      gameObjects.drops.push(new Drop(x, y, chosen.type, value));
    }
    function gameLoop() {
      if (gamePaused || currentState !== GameState.PLAYING) {
        cancelAnimationFrame(animationFrame);
        return;
      }
      
      let now = performance.now();
      let deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1); // Cap deltaTime to prevent large jumps
      lastFrameTime = now;
      let effectiveDelta = deltaTime * 60 * timeScale;
      
      const playArea = getPlayArea();
      const floorHeight = canvas.height * 0.05;
      
      // Clear and draw background
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.imageSmoothingEnabled = true;
      drawGameBackdrop(playArea);
      drawBoundaries(playArea);
      drawFloor(playArea);
      drawBarriers(playArea, floorHeight);
      updateStatsBox();
      
      // Handle laser beams
      if (gameObjects.laserBeams) {
        gameObjects.laserBeams = gameObjects.laserBeams.filter(beam => {
          const elapsed = Date.now() - beam.startTime;
          if (elapsed > beam.duration) return false;
          
          // Draw laser beam
          ctx.save();
          const alpha = 1 - (elapsed / beam.duration);
          ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
          ctx.fillRect(beam.x - beam.width/2, beam.y, beam.width, beam.height);
          
          // Add glow effect
          ctx.shadowColor = 'red';
          ctx.shadowBlur = 20;
          ctx.fillRect(beam.x - beam.width/2, beam.y, beam.width, beam.height);
          ctx.restore();
          
          // Check for paddle collision
          if (!gameObjects.paddle.isInvulnerable) {
            const paddleHitbox = {
              x: gameObjects.paddle.x,
              y: gameObjects.paddle.y,
              width: gameObjects.paddle.width,
              height: gameObjects.paddle.height
            };
            
            if (beam.x >= paddleHitbox.x && 
                beam.x <= paddleHitbox.x + paddleHitbox.width) {
              handlePaddleHit();
            }
          }
          
          return true;
        });
      }
      
      // Update game objects
      updatePlayer(effectiveDelta, playArea);
      updateProjectiles(effectiveDelta, playArea);
      updateBubbles(effectiveDelta, playArea);
      updateDrops(effectiveDelta);
      updateParticles(effectiveDelta);
      updateExplosions(effectiveDelta);
      updateSpeechBubbles(effectiveDelta);
      
      ctx.restore();
      
      // Continue game loop
      animationFrame = requestAnimationFrame(gameLoop);
    }

    // Add helper functions to break down the game loop
    function updatePlayer(dt, playArea) {
      if (!gameObjects.paddle) return;
      
      if (rightPressed && gameObjects.paddle.x < playArea.x + playArea.width - gameObjects.paddle.width) {
        gameObjects.paddle.x += gameObjects.paddle.speed * dt;
      }
      if (leftPressed && gameObjects.paddle.x > playArea.x) {
        gameObjects.paddle.x -= gameObjects.paddle.speed * dt;
      }
      
      gameObjects.paddle.updateVertical(dt, playArea, playArea.height * 0.05);
      gameObjects.paddle.drawSprite(rightPressed || leftPressed);
    }

    function updateProjectiles(dt, playArea) {
      for (let i = gameObjects.projectiles.length - 1; i >= 0; i--) {
        const proj = gameObjects.projectiles[i];
        proj.update(dt);
        if (proj.y + proj.height < playArea.y) {
          gameObjects.projectiles.splice(i, 1);
        } else {
          proj.draw();
        }
      }
    }

    function updateBubbles(dt, playArea) {
      for (let i = gameObjects.bubbles.length - 1; i >= 0; i--) {
        const bubble = gameObjects.bubbles[i];
        bubble.update(dt);
        bubble.draw();
        
        if (isCollidingCircleRect(bubble, gameObjects.paddle.getHitbox())) {
          handleBubblePaddleCollision(bubble, i);
            continue;
          }
        
        for (let j = gameObjects.projectiles.length - 1; j >= 0; j--) {
          const proj = gameObjects.projectiles[j];
          if (isCollidingCircleRect(bubble, { x: proj.x, y: proj.y, width: proj.width, height: proj.height })) {
            handleBubbleProjectileCollision(bubble, i, proj, j);
              break;
          }
        }
      }
      
      // Check for level completion
      if (gameObjects.bubbles.length === 0 && !roundTransitionInProgress) {
        roundTransitionInProgress = true;
        setTimeout(() => {
          startRoundTransition();
        }, 1000);
      }
    }

    class Player {
      constructor(x, y, character = "character1") {
        this.x = x;
        this.y = y;
        this.baseSpeed = 7;
        this.speed = this.baseSpeed;
        this.direction = "right";
        this.lastShotTime = 0;
        this.currentAnimation = "";
        
        // All characters now support full animation sets
        const characterConfig = {
          "character1": {
            idlePrefix: "characterIdle",
            idleShootPrefix: "characteridleShoot",
            runPrefix: "characterRun",
            runShootPrefix: "characterrunShoot",
            useShootingAnimations: true
          },
          "character2": {
            idlePrefix: "characterIdle2",
            idleShootPrefix: "characteridleShoot2",
            runPrefix: "characterRun2",
            runShootPrefix: "characterrunShoot2",
            useShootingAnimations: true
          },
          "character3": {
            idlePrefix: "characterIdle3",
            idleShootPrefix: "characteridleShoot3",
            runPrefix: "characterRun3",
            runShootPrefix: "characterrunShoot3",
            useShootingAnimations: true
          },
          "character4": {
            idlePrefix: "characterIdle4",
            idleShootPrefix: "characteridleShoot4",
            runPrefix: "characterRun4",
            runShootPrefix: "characterrunShoot4",
            useShootingAnimations: true
          },
          "character5": {
            idlePrefix: "characterIdle5",
            idleShootPrefix: "characteridleShoot5",
            runPrefix: "characterRun5",
            runShootPrefix: "characterrunShoot5",
            useShootingAnimations: true
          }
        };

        const config = characterConfig[character] || characterConfig["character1"];
        this.useShootingAnimations = config.useShootingAnimations;
        
        // Initialize all animation sprites for the character with correct prefixes
        this.idleNoActionSprite = new IdleNoActionSprite(this, config.idlePrefix);
        this.idleShootingSprite = new IdleShootingSprite(this, config.idleShootPrefix);
        this.runningSprite = new RunningSprite(this, config.runPrefix);
        this.runningShootingSprite = new RunningShootingSprite(this, config.runShootPrefix);
        
        this.width = this.idleNoActionSprite.width;
        this.height = this.idleNoActionSprite.height;
        this.extraHit = false;
        this.spreadShotUnlocked = false;
        this.jumpVelocity = 0;
        this.isJumping = false;
        this.groundY = y;
        this.powerOrbActive = false;
        this.canDoubleJump = true;
        this.jumpHeight = 0.25; // 25% of play area height
        this.doubleJumpHeight = 0.40; // 40% of play area height
        this.isDoubleJumping = false;
        
        // Jump point tracking system - Optimized
        this.jumpPoints = 0;
        this.jumpStartTime = 0;
        this.continuousJumpTime = 0;
        this.jumpMultiplier = 1;
        this.jumpStats = {
            totalJumps: 0,
            longestJumpStreak: 0,
            highestMultiplier: 1,
            totalJumpPoints: 0,
            lastUpdateTime: 0
        };
        this.lastStatsUpdate = 0;
        this.statsUpdateInterval = 100; // Update stats every 100ms instead of every frame
      }
      
      drawSprite(isRunning) {
        const shooting = (Date.now() - this.lastShotTime < SHOOT_ANIMATION_DURATION);
        let newAnimation = isRunning ? (shooting && this.useShootingAnimations ? "runningShoot" : "running")
                        : (shooting && this.useShootingAnimations ? "idleShoot" : "idle");
        
        if (newAnimation !== this.currentAnimation) {
          this.currentAnimation = newAnimation;
          // Reset all animation frames when switching animations
          if (this.idleNoActionSprite) { this.idleNoActionSprite.frame = 0; this.idleNoActionSprite.frameDelayCounter = 0; }
          if (this.idleShootingSprite) { this.idleShootingSprite.frame = 0; this.idleShootingSprite.frameDelayCounter = 0; }
          if (this.runningSprite) { this.runningSprite.frame = 0; this.runningSprite.frameDelayCounter = 0; }
          if (this.runningShootingSprite) { this.runningShootingSprite.frame = 0; this.runningShootingSprite.frameDelayCounter = 0; }
        }
        
        // Draw the appropriate sprite based on current state
        if (isRunning) {
          if (this.useShootingAnimations && shooting) {
            this.runningShootingSprite.draw();
          } else {
            this.runningSprite.draw();
          }
        } else {
          if (this.useShootingAnimations && shooting) {
            this.idleShootingSprite.draw();
          } else {
            this.idleNoActionSprite.draw();
          }
        }
      }
      getHitbox() { return { x: this.x + 6, y: this.y + 6, width: this.width - 12, height: this.height - 12 }; }
      jump() {
        const playArea = getPlayArea();
        const playAreaHeight = playArea.height;

        if (!this.isJumping) {
            // First jump
            this.isJumping = true;
            this.jumpVelocity = -Math.sqrt(2 * gravity * (playAreaHeight * this.jumpHeight));
            
            // Jump point tracking - Optimized
            this.jumpStartTime = performance.now();
            this.jumpStats.totalJumps++;
            this.jumpPoints++;
            
            if (sfxOn) {
                const jumpSound = new Audio("assets/sounds/jump.wav");
                jumpSound.volume = 0.3;
                jumpSound.play();
            }
        } else if (this.canDoubleJump && !this.isDoubleJumping) {
            // Double jump
            this.isDoubleJumping = true;
            this.jumpVelocity = -Math.sqrt(2 * gravity * (playAreaHeight * this.doubleJumpHeight));
            
            // Additional points for double jump - Optimized
            this.jumpPoints += 2;
            this.jumpStats.totalJumps++;
            
            if (sfxOn) {
                const doubleJumpSound = new Audio("assets/sounds/doubleJump.wav");
                doubleJumpSound.volume = 0.3;
                doubleJumpSound.play();
            }
            createParticles(this.x + this.width/2, this.y + this.height, "#46fbe3", 15);
        }
      }
      updateVertical(dt, playArea, floorHeight) {
        let defaultGround = playArea.y + playArea.height - floorHeight - this.height;
        let platformGround = defaultGround;

        // Check collision with static and moving platforms
        const allPlatforms = [...staticPlatforms, ...movingPlatforms];
        for (const platform of allPlatforms) {
            if (this.x + this.width > platform.x && this.x < platform.x + platform.width) {
                const platformTop = platform.y;
                if (this.y + this.height <= platformTop && 
                    this.y + this.height + this.jumpVelocity * dt >= platformTop) {
                    platformGround = platformTop - this.height;
                }
            }
        }

        this.groundY = platformGround;

        // Update jump multiplier and continuous jump time - Optimized
        const currentTime = performance.now();
        if ((this.isJumping || this.isDoubleJumping) && 
            currentTime - this.lastStatsUpdate >= this.statsUpdateInterval) {
            
            this.continuousJumpTime = (currentTime - this.jumpStartTime) / 1000;
            
            if (this.continuousJumpTime >= 5) {
                const multiplierIncrease = Math.min(0.25, 0.01 + (this.continuousJumpTime - 5) * 0.01);
                this.jumpMultiplier = 1 + multiplierIncrease;
                this.jumpStats.highestMultiplier = Math.max(this.jumpStats.highestMultiplier, this.jumpMultiplier);
                this.jumpStats.longestJumpStreak = Math.max(this.jumpStats.longestJumpStreak, this.continuousJumpTime);
            }
            
            this.lastStatsUpdate = currentTime;
            requestAnimationFrame(() => updateJumpStats());
        }

        if (this.isJumping || this.y < this.groundY) {
            this.y += this.jumpVelocity * dt;
            this.jumpVelocity += gravity * dt * 60;

            if (this.y >= this.groundY) {
                this.y = this.groundY;
                this.jumpVelocity = 0;
                this.isJumping = false;
                this.isDoubleJumping = false;
                this.canDoubleJump = true;
                
                // Landing calculations - Optimized
                if (this.continuousJumpTime > 0) {
                    const pointsEarned = Math.floor(this.jumpPoints * this.jumpMultiplier);
                    this.jumpStats.totalJumpPoints += pointsEarned;
                    
                    // Defer floating text creation to next frame
                    requestAnimationFrame(() => {
                        createFloatingText(this.x + this.width/2, this.y, `+${pointsEarned}`, "#46fbe3");
                    });
                }
                
                this.jumpPoints = 0;
                this.jumpMultiplier = 1;
                this.continuousJumpTime = 0;
            }
        }
      }
    }
    class Drop {
      constructor(x, y, type, value = 0) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.value = value;
        const sp = sprite("drop_" + type);
        this.width = sp ? sp.width : 30;
        this.height = sp ? sp.height : 30;
        this.speedY = 5 * difficultyFactor;
        this.frame = 0;
        this.maxFrames = 6;
        this.frameDelay = 5;
        this.frameDelayCounter = 0;
      }
      draw() {
        this.frameDelayCounter++;
        if (this.frameDelayCounter >= this.frameDelay) {
          this.frame = (this.frame + 1) % this.maxFrames;
          this.frameDelayCounter = 0;
        }
        const dropImg = spriteAnimation("drop_" + this.type, this.frame, this.maxFrames);
        if (dropImg.naturalWidth) { ctx.drawImage(dropImg, this.x, this.y, this.width, this.height); }
        else {
          ctx.font = "24px Arial";
          let emoji;
          switch (this.type) {
            case "deathDrop": emoji = "💀"; break;
            case "extraLife": emoji = "❤️"; break;
            case "speedBoost": emoji = "💨"; break;
            case "shieldBoost": emoji = "🛡️"; break;
            case "coins": emoji = "💰"; break;
            case "weapon": emoji = "🔫"; break;
            case "slowMotion": emoji = "🐢"; break;
            case "spreadShot": emoji = "✴️"; break;
            case "clock": emoji = "⏰"; break;
            case "ultimateBoost": emoji = "🌟"; break;
            case "laserFire": emoji = "⚡"; break;
            case "freeze": emoji = "❄️"; break;
            case "star": emoji = "⭐"; break;
            case "powerOrb": emoji = "🔆"; break;
            default: emoji = "❓"; break;
          }
          ctx.fillText(emoji, this.x, this.y + this.height);
        }
      }
      update(dt) { this.y += this.speedY * dt; }
    }
    function getItemDescription(item) {
      switch (item) {
        case "extraLife": return "❤️ Extra Life: Grants 1 additional health.";
        case "speedBoost": return "💨 Speed Boost: Increases speed for 15 seconds.";
        case "shieldBoost": return "🛡️ Shield Boost: Grants invulnerability for 10 seconds.";
        case "coins": return "💰 Coins: Collect coins to increase your score.";
        case "weapon": return "🔫 Weapon Upgrade: Enables auto-fire for 10 seconds.";
        case "slowMotion": return "🐢 Slow Motion: Slows game time for 10 seconds.";
        case "spreadShot": return "✴️ Spread Shot: Fires multiple projectiles for 10 seconds.";
        case "clock": return "⏰ Clock: Adds 5 seconds to survival time.";
        case "ultimateBoost": return "🌟 Ultimate Boost: Grants shield, auto fire, spread shot, and speed boost for 10 seconds.";
        case "laserFire": return "⚡ Laser Fire: Activates grapple laser gun for 5 seconds.";
        case "freeze": return "❄️ Freeze: Freezes all bubbles for 7 seconds.";
        case "star": return "⭐ Star: Grants temporary invincibility.";
        case "powerOrb": return "🔆 Power Orb: Activates auto-fire, spread shot, and bubble-popping glow for 15 seconds.";
        default: return "";
      }
    }
    function populateItemDirectory() {
      const itemDir = document.getElementById("itemDirectoryListHome");
      if (!itemDir) {
        console.error("Item directory container not found");
        return;
      }
      
      itemDir.innerHTML = ""; // Clear existing content
      
      const items = [
        {
          type: "extraLife",
          emoji: "❤️",
          name: "Extra Life",
          description: "Grants one additional health point. Maximum lives: 9",
          rarity: "Common"
        },
        {
          type: "speedBoost",
          emoji: "💨",
          name: "Speed Boost",
          description: "Increases movement speed by 50% for 15 seconds",
          rarity: "Common"
        },
        {
          type: "shieldBoost",
          emoji: "🛡️",
          name: "Shield Boost",
          description: "Grants temporary invulnerability for 10 seconds",
          rarity: "Common"
        },
        {
          type: "weapon",
          emoji: "🔫",
          name: "Weapon Upgrade",
          description: "Enables rapid-fire auto shooting for 10 seconds",
          rarity: "Common"
        },
        {
          type: "slowMotion",
          emoji: "🐢",
          name: "Slow Motion",
          description: "Slows down game time by 50% for 10 seconds",
          rarity: "Common"
        },
        {
          type: "spreadShot",
          emoji: "✴️",
          name: "Spread Shot",
          description: "Fires three projectiles in a spread pattern for 10 seconds",
          rarity: "Common"
        },
        {
          type: "clock",
          emoji: "⏰",
          name: "Time Extension",
          description: "Adds 5 seconds to the current round timer",
          rarity: "Common"
        },
        {
          type: "ultimateBoost",
          emoji: "🌟",
          name: "Ultimate Power",
          description: "Activates shield, speed boost, auto-fire, and spread shot for 10 seconds",
          rarity: "Rare"
        },
        {
          type: "laserFire",
          emoji: "⚡",
          name: "Laser Beam",
          description: "Activates powerful laser beam weapon for 5 seconds",
          rarity: "Rare"
        },
        {
          type: "freeze",
          emoji: "❄️",
          name: "Freeze Ray",
          description: "Freezes all bubbles in place for 7 seconds",
          rarity: "Rare"
        },
        {
          type: "star",
          emoji: "⭐",
          name: "Star Power",
          description: "Grants extended invincibility and increases all stats",
          rarity: "Epic"
        },
        {
          type: "powerOrb",
          emoji: "🔆",
          name: "Power Orb",
          description: "Ultimate power-up: Auto-fire, spread shot, and instant bubble popping for 15 seconds",
          rarity: "Legendary"
        }
      ];

      items.forEach(item => {
        const itemElement = document.createElement("div");
        itemElement.className = "item-directory-entry";
        itemElement.innerHTML = `
          <div class="item-icon">${item.emoji}</div>
          <div class="item-info">
            <div class="item-name ${item.rarity.toLowerCase()}">${item.name}</div>
            <div class="item-description">${item.description}</div>
            <div class="item-rarity ${item.rarity.toLowerCase()}">${item.rarity}</div>
          </div>
        `;
        itemDir.appendChild(itemElement);
      });

      console.log("Item directory populated with", items.length, "items");
    }
    function updateBackpackUI() {
        if (!window.backpackInventory) window.backpackInventory = {};
        
        const backpackGrids = [
            document.querySelector('#backpackGrid'),
            document.querySelector('.fullScreen #topButtons .backpack-grid')
        ];
        
        backpackGrids.forEach(backpackGrid => {
            if (!backpackGrid) return;
            
            backpackGrid.innerHTML = '';
            
            // Create 9 slots (3x3 grid)
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'backpack-slot';
                slot.dataset.slotIndex = i + 1;
                
                // Add slot number
                const slotNumber = document.createElement('span');
                slotNumber.className = 'slot-number';
                slotNumber.textContent = i + 1;
                slot.appendChild(slotNumber);
                
                // Get item for this slot if exists
                const items = Object.entries(window.backpackInventory);
                if (i < items.length) {
                    const [itemType, count] = items[i];
                    slot.dataset.itemType = itemType;
                    
                    // Add item emoji
                    const itemEmoji = document.createElement('span');
                    itemEmoji.textContent = getItemEmoji(itemType);
                    slot.appendChild(itemEmoji);
                    
                    // Add count if more than 1
                    if (count > 1) {
                        const countSpan = document.createElement('span');
                        countSpan.className = 'item-count';
                        countSpan.textContent = count;
                        slot.appendChild(countSpan);
                    }
                    
                    // Add simple title instead of complex tooltip
                    slot.title = itemType.replace(/([A-Z])/g, ' $1').trim();
                    
                    // Add click handler
                    slot.addEventListener('click', () => useBackpackItem(itemType));
                }
                
                backpackGrid.appendChild(slot);
            }
        });
    }
    function getItemEmoji(itemType) {
      switch (itemType) {
        case "extraLife": return "❤️";
        case "speedBoost": return "💨";
        case "shieldBoost": return "🛡️";
        case "weapon": return "🔫";
        case "slowMotion": return "🐢";
        case "spreadShot": return "✴️";
        case "clock": return "⏰";
        case "ultimateBoost": return "🌟";
        case "laserFire": return "⚡";
        case "freeze": return "❄️";
        case "star": return "⭐";
        case "powerOrb": return "🔆";
        default: return "";
      }
    }
    function addToBackpack(drop) {
      if (!window.backpackInventory) window.backpackInventory = {};
      
      let totalItems = 0;
      for (let type in window.backpackInventory) {
          totalItems += window.backpackInventory[type];
      }
      
      if (totalItems >= 9) {
          showGameMessage("Backpack is full!");
          return;
      }
      
      if (window.backpackInventory[drop.type]) {
          if (window.backpackInventory[drop.type] < 3) {
              window.backpackInventory[drop.type]++;
              showGameMessage(`Added ${drop.type} to backpack!`);
          } else {
              showGameMessage(`${drop.type} slot is full!`);
              return;
          }
      } else {
          window.backpackInventory[drop.type] = 1;
          showGameMessage(`Added ${drop.type} to backpack!`);
      }
      
      setTimeout(updateBackpackUI, 0);
      if (typeof playSound === 'function') {
          playSound('itemPickup');
      }
    }
    function useBackpackItem(itemType) {
      if (!window.backpackInventory) return;
      
      if (window.backpackInventory[itemType] && window.backpackInventory[itemType] > 0) {
          activateBackpackItem(itemType);
          window.backpackInventory[itemType]--;
          if (window.backpackInventory[itemType] <= 0) {
              delete window.backpackInventory[itemType];
          }
          updateBackpackUI();
          playSound('itemUse');
      }
    }
    function activateBackpackItem(itemType) {
      switch (itemType) {
        case "extraLife":
          if (lives < MAX_LIVES) { lives++; showGameMessage("Extra Life Activated!"); }
          break;
        case "speedBoost":
          speedBoostActive = true;
          gameObjects.paddle.speed = gameObjects.paddle.baseSpeed + 5;
          clearTimeout(speedBoostTimeout);
          speedBoostTimeout = setTimeout(() => { speedBoostActive = false; gameObjects.paddle.speed = gameObjects.paddle.baseSpeed; }, 15000);
          showGameMessage("Speed Boost Activated!");
          break;
        case "shieldBoost":
          shieldActive = true;
          clearTimeout(shieldTimeout);
          shieldTimeout = setTimeout(() => { shieldActive = false; }, 8000);
          showGameMessage("Shield Activated!");
          break;
        case "weapon":
          weaponBoostActive = true;
          clearTimeout(weaponBoostTimeout);
          weaponBoostTimeout = setTimeout(() => { weaponBoostActive = false; autoFireActive = false; clearInterval(autoFireInterval); }, AUTO_FIRE_DURATION);
          if (!autoFireActive) {
            autoFireActive = true;
            autoFireInterval = setInterval(shootProjectile, AUTO_FIRE_INTERVAL_MS);
          }
          showGameMessage("Weapon Upgrade Activated!");
          break;
        case "slowMotion":
          slowMotionActive = true;
          timeScale = 0.5;
          clearTimeout(slowMotionTimeout);
          slowMotionTimeout = setTimeout(() => { slowMotionActive = false; timeScale = 1.0; }, 10000);
          showGameMessage("Slow Motion Activated!");
          break;
        case "spreadShot":
          spreadShotActive = true;
          clearTimeout(spreadShotTimeout);
          spreadShotTimeout = setTimeout(() => { spreadShotActive = false; }, 8000);
          showGameMessage("Spread Shot Activated!");
          break;
        case "clock":
          roundTimeRemaining += 5;
          showGameMessage("Extra Time Activated!");
          break;
        case "ultimateBoost":
          shieldActive = true;
          speedBoostActive = true;
          weaponBoostActive = true;
          spreadShotActive = true;
          clearTimeout(shieldTimeout);
          shieldTimeout = setTimeout(() => { shieldActive = false; }, 10000);
          clearTimeout(speedBoostTimeout);
          speedBoostTimeout = setTimeout(() => { speedBoostActive = false; gameObjects.paddle.speed = gameObjects.paddle.baseSpeed; }, 10000);
          clearTimeout(weaponBoostTimeout);
          weaponBoostTimeout = setTimeout(() => { weaponBoostActive = false; autoFireActive = false; clearInterval(autoFireInterval); }, 10000);
          clearTimeout(spreadShotTimeout);
          spreadShotTimeout = setTimeout(() => { spreadShotActive = false; }, 10000);
          showGameMessage("Ultimate Boost Activated!");
          break;
        case "laserFire":
          laserFireActive = true;
          clearTimeout(laserFireTimeout);
          laserFireTimeout = setTimeout(() => { laserFireActive = false; }, 5000);
          showGameMessage("Grapple Laser Activated!");
          break;
        default:
          break;
      }
    }
    class Explosion {
      constructor(x, y, assetBase, maxFrames, frameDuration = 4) {
        this.x = x;
        this.y = y;
        this.assetBase = assetBase;
        this.maxFrames = maxFrames;
        this.frameDuration = frameDuration;
        this.currentFrame = 0;
        this.frameCount = 0;
      }
      update() {
        this.frameCount++;
        if (this.frameCount >= this.frameDuration) {
          this.currentFrame++;
          this.frameCount = 0;
        }
      }
      draw() {
        if (this.currentFrame < this.maxFrames) {
          const img = spriteAnimation(this.assetBase, this.currentFrame, this.maxFrames);
          if (img.naturalWidth) { ctx.drawImage(img, this.x, this.y); }
        }
      }
      isFinished() { return this.currentFrame >= this.maxFrames; }
    }
    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3 + 2;
        this.dx = (Math.random() - 0.5) * 4 * difficultyFactor;
        this.dy = (Math.random() - 0.5) * 4 * difficultyFactor;
        this.alpha = 1.0;
        this.color = color;
        this.life = 60;
      }
      update(dt) {
        this.x += this.dx * dt;
        this.y += this.dy * dt;
        this.life--;
        this.alpha = this.life / 60;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
      }
    }
    function createParticles(x, y, color, count = 20) {
      for (let i = 0; i < count; i++) { gameObjects.particles.push(new Particle(x, y, color)); }
    }
    function getPlayArea() {
      const margin = 0;
      return { x: margin, y: margin, width: canvas.width - 2 * margin, height: canvas.height - 2 * margin };
    }
    function startRoundTransition() {
        roundTransitionInProgress = true;
        let countdown = 3;
        const overlay = document.getElementById("roundTransitionOverlay");
        
        // Ensure overlay exists
        if (!overlay) {
            const newOverlay = document.createElement("div");
            newOverlay.id = "roundTransitionOverlay";
            newOverlay.className = "round-transition-overlay";
            document.body.appendChild(newOverlay);
        }
        
        overlay.style.display = "flex";
        overlay.style.flexDirection = "column";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        
        // Update difficulty for next round
        const nextLevel = level + 1;
        let nextDifficulty = getDifficultyText(nextLevel);
        difficultyFactor = calculateDifficultyFactor(nextLevel);
        
        // Special round messages
        let specialRoundMsg = "";
        if (nextLevel % 10 === 0) {
            specialRoundMsg = "BOSS ROUND!";
        } else if (nextLevel % 5 === 0) {
            specialRoundMsg = "Golden Bubble Round!";
        }
        
        requestAnimationFrame(() => {
            overlay.style.opacity = "1";
            overlay.innerHTML = `
                <div class="round-transition-content">
                    <div class="round-number">ROUND ${nextLevel}</div>
                    <div class="round-difficulty">${nextDifficulty}</div>
                    ${specialRoundMsg ? `<div class="special-round">${specialRoundMsg}</div>` : ''}
                    <div class="countdown">${countdown}</div>
                </div>
            `;
        });
        
        // Play transition sound
        if (sfxOn) {
            const transitionSound = new Audio("assets/sounds/round_transition.mp3");
            transitionSound.volume = 0.3;
            transitionSound.play();
        }
        
        const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                const countdownEl = overlay.querySelector('.countdown');
                if (countdownEl) {
                    countdownEl.textContent = countdown;
                    // Play countdown sound
                    if (sfxOn) {
                        const tickSound = new Audio("assets/sounds/tick.mp3");
                        tickSound.volume = 0.2;
                        tickSound.play();
                    }
                }
            } else {
                clearInterval(countdownInterval);
                overlay.style.opacity = "0";
                
                setTimeout(() => {
                    overlay.style.display = "none";
                    roundTransitionInProgress = false;
                    startNewRound();
                    
                    // Play round start sound
                    if (sfxOn) {
                        const startSound = new Audio("assets/sounds/round_start.mp3");
                        startSound.volume = 0.3;
                        startSound.play();
                    }
                }, 500);
            }
        }, 1000);
    }

    function calculateDifficultyFactor(level) {
        // Base difficulty starts at 1.0 and increases with level
        let factor = 1.0;
        
        // Gradual increase every level
        factor += (level - 1) * 0.1;
        
        // Additional increase every 5 levels
        factor += Math.floor(level / 5) * 0.2;
        
        // Cap the maximum difficulty factor
        return Math.min(factor, 3.0);
    }

    function getDifficultyText(level) {
        if (level < 5) return "Easy";
        if (level < 10) return "Normal";
        if (level < 15) return "Hard";
        if (level < 20) return "Very Hard";
        if (level < 25) return "Extreme";
        return "Insane";
    }

    let gameOverSpriteFrame = 0;
    const gameOverSpriteMaxFrames = 6;
    const gameOverFrameDelay = 100;
    let gameOverAnimationInterval = null;
    function startGameOverAnimation() {
      const img = document.getElementById("gameOverSprite");
      if (!img) return;
      gameOverSpriteFrame = 0;
      if (gameOverAnimationInterval) clearInterval(gameOverAnimationInterval);
      gameOverAnimationInterval = setInterval(() => {
        gameOverSpriteFrame = (gameOverSpriteFrame % gameOverSpriteMaxFrames) + 1;
        img.src = `assets/images/gameOver_${gameOverSpriteFrame}.png`;
      }, gameOverFrameDelay);
    }
    function stopGameOverAnimation() {
      if (gameOverAnimationInterval) clearInterval(gameOverAnimationInterval);
    }
    let currentCharacterSelection = "character1";
    const portraitMap = {
      "character1": "assets/images/character1_portrait.gif",
      "character2": "assets/images/character2_portrait.gif",
      "character3": "assets/images/character3_portrait.gif",
      "character4": "assets/images/character4_portrait.gif",
      "character5": "assets/images/character5_portrait.gif"
    };
    function initGame(selectedCharacter = "character1") {
        return new Promise((resolve) => {
      canvas = document.getElementById("gameCanvas");
      if (!canvas) return;
      ctx = canvas.getContext("2d");
      if (!ctx) return;

            // Force an initial canvas size adjustment
            adjustCanvasSize();
            
            // Wait for a frame to ensure canvas size is properly set
            requestAnimationFrame(() => {
      const playArea = getPlayArea();
      const floorHeight = canvas.height * 0.05;
      const idleImg = spritePNG("characterIdle_1");
      const idleWidth = idleImg.naturalWidth ? Math.floor(idleImg.naturalWidth * 1.7) : 85;
      const idleHeight = idleImg.naturalHeight ? Math.floor(idleImg.naturalHeight * 1.7) : 85;

                // Initialize player position
                gameObjects.paddle = new Player(
                    playArea.x + playArea.width / 2 - idleWidth / 2,
                    playArea.y + playArea.height - floorHeight - idleHeight,
                    selectedCharacter
                );
      gameObjects.paddle.groundY = playArea.y + playArea.height - floorHeight - gameObjects.paddle.height;

                // Reset game objects
                gameObjects.bubbles = [];
                gameObjects.projectiles = [];
                gameObjects.drops = [];
                gameObjects.particles = [];
                gameObjects.explosions = [];
                gameObjects.speechBubbles = [];
                gameObjects.companion = null;

                // Reset game state
                score = 0;
                lives = 3;
                level = 1;
                combo = 0;
      roundTimeRemaining = 25;
      difficultyFactor = 1.0;
      currentDifficulty = "Easy";

                // Reset power-ups and effects
                speedBoostActive = false;
                shieldActive = false;
                weaponBoostActive = false;
                spreadShotActive = false;
                slowMotionActive = false;
                paddleInvulnerable = false;
      timeScale = 1.0;

                // Clear all timeouts
                clearTimeout(speedBoostTimeout);
                clearTimeout(shieldTimeout);
                clearTimeout(weaponBoostTimeout);
                clearTimeout(spreadShotTimeout);
                clearTimeout(slowMotionTimeout);

                // Initialize first round
      spawnBubbles(level);

                // Reset controls
                rightPressed = false;
                leftPressed = false;
                shakeTime = 0;
                shakeIntensity = 0;

                // Update UI
      updateProfileBox();
      updateDifficultyIndicator();
      updateCoinPanel();
      updateBackpackUI();
                updateBonusGameUI();
                updateAchievements();

                // Wait for another frame to ensure everything is ready
                requestAnimationFrame(() => {
                    resolve();
                });
            });
        });
    }
    function spawnBubbles(currentLevel) {
        const playArea = getPlayArea();
        updateDifficultyIndicator();
        
        gameObjects.bubbles = [];
        
        // More gradual base bubble count scaling
        const baseBubbleCount = Math.min(1 + Math.floor(Math.sqrt(currentLevel / 2)), 6);
        
        // Boss levels (every 10th level)
        if (currentLevel % 10 === 0) {
            const x = playArea.x + playArea.width / 2;
            const y = playArea.y + 50;
            const dx = (Math.random() < 0.5 ? -1 : 1) * (2 * difficultyFactor);
            const dy = -2 * difficultyFactor;
            
            // Spawn boss bubble
            const BossType = selectRandomBossType();
            gameObjects.bubbles.push(new BossType(x, y, dx, dy));
            
            // Add support bubbles in higher boss levels, but more gradually
            if (currentLevel >= 30) { // Increased from 20 to 30
                const supportCount = Math.min(Math.floor((currentLevel - 30) / 20), 2); // Reduced max support bubbles
                for (let i = 0; i < supportCount; i++) {
                    const supportX = playArea.x + 50 + Math.random() * (playArea.width - 100);
                    const supportY = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
                    const supportDx = (Math.random() < 0.5 ? -1 : 1) * (2 * difficultyFactor);
                    const supportDy = -2 * difficultyFactor;
                    gameObjects.bubbles.push(new Bubble(supportX, supportY, 30, supportDx, supportDy, "medium", "normal"));
                }
            }
            return;
        }
        
        // Golden bubble levels (every 5th level, not divisible by 10)
        if (currentLevel % 5 === 0 && currentLevel % 10 !== 0) {
            const x = playArea.x + playArea.width / 2;
            const y = playArea.y + 50;
            const dx = (Math.random() < 0.5 ? -1 : 1) * (2 * difficultyFactor);
            const dy = -2 * difficultyFactor;
            
            // Spawn golden bubble
            gameObjects.bubbles.push(new GoldenBubble(x, y, dx, dy));
            
            // Add support bubbles more gradually
            const supportCount = Math.min(Math.floor(currentLevel / 10), 3); // Reduced from level/5 to level/10
            for (let i = 0; i < supportCount; i++) {
                spawnRandomBubble(playArea);
            }
            return;
        }
        
        // Regular levels with more gradual progression
        if (currentLevel <= 8) { // Extended early game phase
            // Basic levels: Simple patterns, normal bubbles only
            for (let i = 0; i < baseBubbleCount; i++) {
                spawnBasicBubble(playArea, currentLevel);
            }
            
            // Add simple patterns less frequently in early levels
            if (currentLevel > 3 && Math.random() < 0.3 + (currentLevel * 0.1)) {
                if (Math.random() < 0.7) {
                    spawnBubblePattern("circle", playArea);
                } else {
                    spawnBubblePattern("wave", playArea);
                }
            }
        } else {
            // Advanced levels: Mix of patterns and special bubbles
            const patterns = ["circle", "wave", "spiral"];
            // Add more complex patterns gradually
            if (currentLevel > 15) patterns.push("zigzag", "mixed");
            if (currentLevel > 20) patterns.push("figure-8");
            
            const chosenPattern = patterns[Math.floor(Math.random() * patterns.length)];
            spawnBubblePattern(chosenPattern, playArea);
            
            // Add special bubbles after level 10, more gradually
            if (currentLevel > 10) {
                const specialCount = Math.min(Math.floor((currentLevel - 10) / 5), 2);
                for (let i = 0; i < specialCount; i++) {
                    spawnSpecialBubble(playArea, currentLevel);
                }
            }
            
            // Add random bubbles more gradually
            const randomCount = Math.max(1, Math.floor(baseBubbleCount/3));
            for (let i = 0; i < randomCount; i++) {
                spawnRandomBubble(playArea);
            }
        }
    }

    function spawnBasicBubble(playArea, currentLevel) {
        const x = playArea.x + 50 + Math.random() * (playArea.width - 100);
        const y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
        const dx = (Math.random() < 0.5 ? -1 : 1) * (1 + Math.random() * 1.5); // Reduced speed
        const dy = -(2 + Math.random() * 2); // Reduced speed
        const radius = 15 + Math.random() * 8; // Slightly smaller bubbles
        gameObjects.bubbles.push(new Bubble(x, y, radius, dx, dy, "normal", "normal"));
    }

    function spawnSpecialBubble(playArea, currentLevel) {
        const x = playArea.x + 50 + Math.random() * (playArea.width - 100);
        const y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
        const dx = (Math.random() < 0.5 ? -1 : 1) * (1 + Math.random() * 1.5);
        const dy = -(2 + Math.random() * 2);
        
        const specialTypes = [
            { type: "explosive", minLevel: 10, weight: 3 }, // Increased min level from 7
            { type: "teleporting", minLevel: 12, weight: 2 }, // Increased from 8
            { type: "shatter", minLevel: 14, weight: 2 }, // Increased from 9
            { type: "phase", minLevel: 16, weight: 1 }, // Increased from 11
            { type: "ninja", minLevel: 18, weight: 1 }, // Increased from 12
            { type: "prism", minLevel: 20, weight: 1 } // Increased from 15
        ];
        
        // Filter available types based on current level
        const availableTypes = specialTypes.filter(t => currentLevel >= t.minLevel);
        if (availableTypes.length === 0) return spawnBasicBubble(playArea, currentLevel);
        
        // Weight-based selection
        const totalWeight = availableTypes.reduce((sum, t) => sum + t.weight, 0);
        let random = Math.random() * totalWeight;
        const selectedType = availableTypes.find(t => {
            random -= t.weight;
            return random <= 0;
        });
        
        if (!selectedType) return spawnBasicBubble(playArea, currentLevel);
        
        const bubble = new Bubble(x, y, 20, dx, dy, "medium", selectedType.type);
        gameObjects.bubbles.push(bubble);
    }

    // Event Listeners for Full Screen Toggle and Start Game
    document.getElementById("fullScreenToggle").addEventListener("change", (e) => {
      const mainContainer = document.getElementById("mainContainer");
      if (e.target.checked) {
        if (document.documentElement.requestFullscreen) { document.documentElement.requestFullscreen(); }
        mainContainer.classList.add("fullScreen");
        // Reset control panel state
        const panel = document.getElementById('topButtons');
        panel.classList.remove('minimized');
        const button = panel.querySelector('.minimize-button');
        button.textContent = '▼';
      } else {
        if (document.exitFullscreen) { document.exitFullscreen(); }
        mainContainer.classList.remove("fullScreen");
      }
      adjustCanvasSize();
      updateBackpackUI();
    });
    document.getElementById("fullScreenToggleSettings").addEventListener("change", (e) => {
      const mainContainer = document.getElementById("mainContainer");
      if (e.target.checked) {
        if (document.documentElement.requestFullscreen) { document.documentElement.requestFullscreen(); }
        mainContainer.classList.add("fullScreen");
      } else {
        if (document.exitFullscreen) { document.exitFullscreen(); }
        mainContainer.classList.remove("fullScreen");
      }
      adjustCanvasSize();
      updateBackpackUI();
    });
    document.getElementById("startButton").addEventListener("click", async function () {
      username = document.getElementById("usernameInput").value.trim();
      currentCharacterSelection = document.getElementById("characterSelect").value;
      const startError = document.getElementById("startError");
      startError.innerText = "";
        
        if (username === "") {
            startError.innerText = "Please enter a username.";
            return;
        }

        // Reset game state
        gamePaused = false;
        currentState = GameState.START;
        roundTransitionInProgress = false;
        lastFrameTime = performance.now();
        
      document.getElementById("homeProfilePic").src = portraitMap[currentCharacterSelection];
      document.getElementById("homeProfileUsername").innerText = "Username: " + username;
      document.getElementById("homeProfileLevel").innerText = "Level: 1";
      document.getElementById("homeProfileTopScore").innerText = "Top Score: 0";
      document.getElementById("startScreen").style.display = "none";

        // Handle music transition
      homeBgMusic.pause();
      bgMusic.volume = 0;
      bgMusic.play();
      let fadeInterval = setInterval(() => {
        if (bgMusic.volume < parseFloat(document.getElementById("bgVolume").value)) {
          bgMusic.volume = Math.min(bgMusic.volume + 0.1, parseFloat(document.getElementById("bgVolume").value));
            } else {
                clearInterval(fadeInterval);
            }
      }, 100);

      updateGameState(GameState.CUTSCENE);
        showCutscene('start', async () => {
        document.getElementById("mainContainer").style.display = "flex";
        document.getElementById("gameCanvas").style.display = "block";
            
            // Initialize game and wait for completion
            await initGame(currentCharacterSelection);
            
        document.getElementById("profilePic").src = portraitMap[currentCharacterSelection];
        updateCoinPanel();
            
            // Start the game
        startRoundTimer();
        updateGameState(GameState.PLAYING);
            lastFrameTime = performance.now();
            gameLoop();
      });
    });
    document.getElementById("restartButton").addEventListener("click", restartGame);
    document.getElementById("restartGameButton").addEventListener("click", restartGame);
    document.getElementById("homeButton").addEventListener("click", function () {
      // Stop all game processes
      clearInterval(timerInterval);
      cancelAnimationFrame(animationFrame);
      stopGameOverAnimation();
      stopEffectSounds();
      
      // Reset music
      bgMusic.pause();
      bgMusic.currentTime = 0;
      homeBgMusic.play();
      
      // Hide game screens
      document.getElementById("gameCanvas").style.display = "none";
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("mainContainer").style.display = "none";
      
      // Show home screen
      document.getElementById("startScreen").style.display = "flex";
      
      // Update game state
      updateGameState(GameState.START);
    });
    document.getElementById("homeScreenButton").addEventListener("click", function () {
      // Stop all game processes
      clearInterval(timerInterval);
      cancelAnimationFrame(animationFrame);
      stopGameOverAnimation();
      stopEffectSounds();
      
      // Reset music
      bgMusic.pause();
      bgMusic.currentTime = 0;
      homeBgMusic.play();
      
      // Hide game screens
      document.getElementById("gameCanvas").style.display = "none";
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("mainContainer").style.display = "none";
      
      // Show home screen
      document.getElementById("startScreen").style.display = "flex";
      
      // Update game state
      updateGameState(GameState.START);
    });
    document.getElementById("pauseButton").addEventListener("click", () => {
      gamePaused = !gamePaused;
      document.getElementById("pauseButton").innerText = gamePaused ? "Resume" : "Pause";
      if (!gamePaused && currentState === GameState.PLAYING) {
        gameLoop();
      }
      updateGameState(gamePaused ? GameState.PAUSED : GameState.PLAYING);
    });
    document.getElementById("fsPauseButton").addEventListener("click", () => { document.getElementById("pauseButton").click(); });
    document.getElementById("fsSettingsButton").addEventListener("click", () => { document.getElementById("settingsButton").click(); });
    document.getElementById("fsRestartButton").addEventListener("click", () => { document.getElementById("restartGameButton").click(); });
    document.getElementById("fsHomeButton").addEventListener("click", () => { document.getElementById("homeScreenButton").click(); });
    document.getElementById("settingsButton").addEventListener("click", () => { document.getElementById("settingsOverlay").style.display = "block"; });
    document.getElementById("closeSettings").addEventListener("click", () => {
      document.getElementById("settingsOverlay").style.display = "none";
      controlLeft = document.getElementById("keyLeft").value.toLowerCase();
      controlRight = document.getElementById("keyRight").value.toLowerCase();
      controlShoot = document.getElementById("keyShoot").value || " ";
      bgMusic.volume = parseFloat(document.getElementById("bgVolume").value);
      audioPop.volume = parseFloat(document.getElementById("sfxVolume").value);
      audioPowerup.volume = parseFloat(document.getElementById("sfxVolume").value);
    });
    document.getElementById("bgMusicToggle").addEventListener("change", (e) => {
      bgMusicOn = e.target.checked;
      if (bgMusicOn) { bgMusic.play(); } else { bgMusic.pause(); }
    });
    document.getElementById("sfxToggle").addEventListener("change", (e) => { sfxOn = e.target.checked; });
    document.getElementById("customMusic").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (event) {
          bgMusic.src = event.target.result;
          if (bgMusicOn) { bgMusic.play(); }
        };
        reader.readAsDataURL(file);
      }
    });
    let leaderboardResetInterval = parseInt(document.getElementById("resetInterval").value, 10) * 60000;
    let leaderboardResetTimer = null;
    function resetLeaderboard() {
      firebase.database().ref('leaderboard').remove();
      fetchHomeLeaderboard();
      populateGameOverLeaderboardFirebase();
    }
    function startLeaderboardResetTimer() {
      leaderboardResetTimer = setInterval(resetLeaderboard, leaderboardResetInterval);
    }
    document.getElementById("resetInterval").addEventListener("change", function (e) {
      if (leaderboardResetTimer) { clearInterval(leaderboardResetTimer); }
      leaderboardResetInterval = parseInt(e.target.value, 10) * 60000;
      startLeaderboardResetTimer();
    });
    startLeaderboardResetTimer();
    document.addEventListener("keydown", function (e) {
      if (gamePaused || currentState !== GameState.PLAYING) return;
      
      const key = e.key.toLowerCase();
      if (key === controlRight || e.key === "arrowright") {
        rightPressed = true;
        if (gameObjects.paddle) { gameObjects.paddle.direction = "right"; }
      }
      else if (key === controlLeft || e.key === "arrowleft") {
        leftPressed = true;
        if (gameObjects.paddle) { gameObjects.paddle.direction = "left"; }
      }
      else if (key === controlShoot || key === " " || e.code === "Space") {
        e.preventDefault(); // Prevent space from scrolling
        shootProjectile();
      }
      else if (key === "s") {
        const backpackGrid = document.getElementById("backpackGrid");
        if (backpackGrid && backpackGrid.children.length > 0) {
          const firstSlot = backpackGrid.children[0];
          const itemType = firstSlot.dataset.itemType;
          if (itemType) {
            useBackpackItem(itemType);
          }
        }
      }
      else if (key === "w") {
        if (gameObjects.paddle) { gameObjects.paddle.jump(); }
      }
    });
    document.addEventListener("keyup", function (e) {
      const key = e.key.toLowerCase();
      if (key === controlRight || e.key === "arrowright") { rightPressed = false; }
      else if (key === controlLeft || e.key === "arrowleft") { leftPressed = false; }
    });
    document.getElementById("gameCanvas").addEventListener("click", function(e) {
        e.preventDefault();
        if (gamePaused || currentState !== GameState.PLAYING) return;
        shootProjectile();
    });

    document.getElementById("gameCanvas").addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (!gameObjects.paddle || gamePaused || currentState !== GameState.PLAYING) return;
        
        const rect = e.target.getBoundingClientRect();
        const touchX = e.touches[0].clientX - rect.left;
        const paddleCenter = gameObjects.paddle.x + gameObjects.paddle.width / 2;
        
        if (touchX < paddleCenter) {
            leftPressed = true;
            rightPressed = false;
            gameObjects.paddle.direction = "left";
        } else {
            rightPressed = true;
            leftPressed = false;
            gameObjects.paddle.direction = "right";
        }
        
        shootProjectile();
    }, { passive: false });

    document.getElementById("gameCanvas").addEventListener("touchmove", function(e) {
        e.preventDefault();
        if (!gameObjects.paddle || gamePaused || currentState !== GameState.PLAYING) return;
        
        const rect = e.target.getBoundingClientRect();
        const touchX = e.touches[0].clientX - rect.left;
        const paddleCenter = gameObjects.paddle.x + gameObjects.paddle.width / 2;
        
        if (touchX < paddleCenter) {
            leftPressed = true;
            rightPressed = false;
            gameObjects.paddle.direction = "left";
        } else {
            rightPressed = true;
            leftPressed = false;
            gameObjects.paddle.direction = "right";
        }
    }, { passive: false });

    document.getElementById("gameCanvas").addEventListener("touchend", function(e) {
        e.preventDefault();
        leftPressed = false;
        rightPressed = false;
    });

    // Update window resize handler
    window.addEventListener("resize", function() {
        adjustCanvasSize();
        setTimeout(adjustCanvasSize, 100);
    });

    // Update shootProjectile function to handle mouse position
    function shootProjectile() {
        const player = gameObjects.paddle;
        if (!player) return;
        
        player.lastShotTime = Date.now();
        const projImg = spritePNG("projectileAnim_1");
        const centerX = player.x + player.width / 2 - (projImg.naturalWidth ? projImg.naturalWidth / 2 : 5);
        const centerY = player.y + player.height / 2 - (projImg.naturalHeight ? projImg.naturalHeight / 2 : 5);
        
        if (laserFireActive) {
            gameObjects.projectiles.push(new GrappleLaserProjectile(centerX, centerY));
        } else if (player.spreadShotUnlocked || spreadShotActive) {
            gameObjects.projectiles.push(new Projectile(centerX, centerY, -0.1));
            gameObjects.projectiles.push(new Projectile(centerX, centerY, 0));
            gameObjects.projectiles.push(new Projectile(centerX, centerY, 0.1));
        } else {
            gameObjects.projectiles.push(new Projectile(centerX, centerY, 0));
        }
        
        if (sfxOn) {
            audioPop.currentTime = 0;
            audioPop.play();
        }
    }

    function gameOver() {
        updateGameState(GameState.GAME_OVER);
        cancelAnimationFrame(animationFrame);
        stopEffectSounds();
        bgMusic.pause();
        bgMusic.currentTime = 0;
        homeBgMusic.play();

        // Update player stats
        const stats = {
            score: score,
            level: level,
            itemsCollected: backpackInventory
        };
        playerStats.updatePlayerStats(username, stats);

        // Update UI
        document.getElementById("finalScore").innerText = `Final Score: ${score}`;
        document.getElementById("gameOverScreen").style.display = "block";
        updateLeaderboard();
        
        // Show achievements
        const achievements = playerStats.getPlayerAchievements(username);
        if (achievements.length > 0) {
            const achievementsList = document.createElement("div");
            achievementsList.className = "achievements-list";
            achievements.forEach(achievement => {
                const div = document.createElement("div");
                div.className = "achievement-item";
                div.textContent = achievement;
                achievementsList.appendChild(div);
            });
            document.getElementById("gameOverScreen").insertBefore(achievementsList, document.getElementById("restartButton"));
        }
    }

    function restartGame() {
      // Stop any ongoing game processes
      stopEffectSounds();
      clearInterval(timerInterval);
      cancelAnimationFrame(animationFrame);
      stopGameOverAnimation();
      
      // Reset game state
      gamePaused = false;
      score = 0;
      lives = 3;
      level = 1;
      combo = 0;
      roundTimeRemaining = 25;
      difficultyFactor = 1.0;
      currentDifficulty = "Easy";
      backpackInventory = {};
      coinsCollected = 0;
      xp = 0;
      
      // Reset power-ups and effects
      speedBoostActive = false;
      shieldActive = false;
      weaponBoostActive = false;
      spreadShotActive = false;
      slowMotionActive = false;
      paddleInvulnerable = false;
      timeScale = 1.0;
      
      // Clear all timeouts and intervals
      clearTimeout(speedBoostTimeout);
      clearTimeout(shieldTimeout);
      clearTimeout(weaponBoostTimeout);
      clearTimeout(spreadShotTimeout);
      clearTimeout(slowMotionTimeout);
      clearInterval(autoFireInterval);
      autoFireActive = false;
      
      // Reset game objects
      gameObjects = {
          bubbles: [],
          projectiles: [],
          drops: [],
          particles: [],
          explosions: [],
          speechBubbles: [],
          paddle: null,
          companion: null
      };
      
      // Hide all game screens
      document.getElementById('gameOverScreen').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'none';
      document.getElementById('mainContainer').style.display = 'none';
      
      // Show restart cutscene
      updateGameState(GameState.CUTSCENE);
      showRestartCutscene(async () => {
          // Show game canvas
          document.getElementById('gameCanvas').style.display = 'block';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Initialize new game with current character
          await initGame(currentCharacterSelection);
          
          // Reset music
          if (bgMusic) {
              bgMusic.currentTime = 0;
              bgMusic.volume = parseFloat(document.getElementById('bgVolume').value || 0.5);
              if (bgMusicOn) bgMusic.play();
          }
          
          // Start round 1
          level = 1;
          roundTimeRemaining = 25;
          startRoundTimer();
          
          // Spawn initial bubbles for round 1
          const playArea = getPlayArea();
          spawnBubbles(1); // Explicitly pass level 1
          
          // Update all UI elements
          updateProfileBox();
          updateDifficultyIndicator();
          updateCoinPanel();
          updateBackpackUI();
          updateBonusGameUI();
          updateAchievements();
          
          // Start game loop
          updateGameState(GameState.PLAYING);
          lastFrameTime = performance.now();
          gameLoop();
      });
    }

    function updateLeaderboard() {
        const leaderboard = playerStats.getLeaderboard();
        const sortedLeaderboard = leaderboard.slice(0, 3);
        
        // Update home screen leaderboard
        const homeLeaderboardList = document.getElementById("homeLeaderboardList");
        homeLeaderboardList.innerHTML = "";
        sortedLeaderboard.forEach((entry, index) => {
            const div = document.createElement("div");
            div.className = "leaderboard-entry";
            div.innerHTML = `
                <span class="leaderboard-rank">#${index + 1}</span>
                <span class="leaderboard-username">${entry.username}</span>
                <span class="leaderboard-score">${Math.floor(entry.score)}</span>
            `;
            homeLeaderboardList.appendChild(div);
        });

        // Update in-game leaderboard
        const combinedLeaderboard = document.getElementById("combinedLeaderboard");
        combinedLeaderboard.innerHTML = "<h3>Top 3 Players</h3>";
        sortedLeaderboard.forEach((entry, index) => {
            const div = document.createElement("div");
            div.className = "leaderboard-entry";
            div.innerHTML = `
                <span class="leaderboard-rank">#${index + 1}</span>
                <span class="leaderboard-username">${entry.username}</span>
                <span class="leaderboard-score">${Math.floor(entry.score)}</span>
            `;
            combinedLeaderboard.appendChild(div);
        });
    }

    // Add initialization function
    function initializeHomeScreen() {
        populateItemDirectory();
        // Any other home screen initialization can go here
    }

    // Call this when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        initializeHomeScreen();
        createSparkles(); // Initialize sparkle effects
    });

    // Also call it when returning to home screen
    document.getElementById("homeButton").addEventListener("click", function() {
        initializeHomeScreen();
    });

    document.getElementById("homeScreenButton").addEventListener("click", function() {
        initializeHomeScreen();
    });

    // Add these new bubble classes after the existing bubble classes

    class PhaseBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 35, dx, dy, "phase");
            this.phaseTime = 0;
            this.phaseInterval = 2000; // Phase every 2 seconds
            this.isPhased = false;
            this.color = "#7B68EE"; // Medium slate blue
            this.originalRadius = this.radius;
        }

        draw() {
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            
            // Create phasing effect
            if (this.isPhased) {
                ctx.fillStyle = "rgba(123, 104, 238, 0.3)";
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.setLineDash([5, 5]);
            } else {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = "#ffffff";
            }
            
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            
            // Add inner glow effect
            const gradient = ctx.createRadialGradient(
                this.x, this.y, 0,
                this.x, this.y, this.radius
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.3)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.restore();
        }

      update(dt) {
        super.update(dt);
            this.phaseTime += dt * 1000;
            
            if (this.phaseTime >= this.phaseInterval) {
                this.isPhased = !this.isPhased;
                this.phaseTime = 0;
                this.radius = this.isPhased ? this.originalRadius * 1.2 : this.originalRadius;
            }
        }
    }

    class ClusterBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 45, dx, dy, "cluster");
            this.orbitRadius = 20;
            this.orbitAngle = 0;
            this.orbitSpeed = 0.05;
            this.satelliteCount = 4;
            this.satellites = [];
            
            // Initialize satellite bubbles
            for (let i = 0; i < this.satelliteCount; i++) {
                this.satellites.push({
                    angle: (i * 2 * Math.PI) / this.satelliteCount,
                    radius: 10
                });
            }
        }

        draw() {
            // Draw main bubble
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#FF69B4"; // Hot pink
            ctx.fill();
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();

            // Draw orbiting satellites
            this.satellites.forEach(satellite => {
                const satX = this.x + Math.cos(this.orbitAngle + satellite.angle) * this.orbitRadius;
                const satY = this.y + Math.sin(this.orbitAngle + satellite.angle) * this.orbitRadius;
                
                ctx.beginPath();
                ctx.arc(satX, satY, satellite.radius, 0, Math.PI * 2);
                ctx.fillStyle = "#FF1493"; // Deep pink
                ctx.fill();
                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();
            });
            
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            this.orbitAngle += this.orbitSpeed * dt * 60;
        }

        split() {
            const newBubbles = [];
            this.satellites.forEach(satellite => {
                const angle = this.orbitAngle + satellite.angle;
                const satX = this.x + Math.cos(angle) * this.orbitRadius;
                const satY = this.y + Math.sin(angle) * this.orbitRadius;
                const newDx = Math.cos(angle) * 3;
                const newDy = Math.sin(angle) * 3;
                newBubbles.push(new Bubble(satX, satY, satellite.radius, newDx, newDy, "tiny"));
            });
            return newBubbles;
        }
    }

    class NinjaBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 25, dx, dy, "ninja");
            this.dashCooldown = 3000; // 3 seconds between dashes
            this.lastDashTime = 0;
            this.isDashing = false;
            this.dashSpeed = 8;
            this.originalSpeed = { dx: dx, dy: dy };
            this.color = "#000000";
        }

        draw() {
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            
            if (this.isDashing) {
                // Create motion blur effect during dash
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.shadowColor = "#ff0000";
                ctx.shadowBlur = 20;
            } else {
                ctx.fillStyle = this.color;
                // Add ninja star pattern
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(
                        this.x + Math.cos(angle) * this.radius,
                        this.y + Math.sin(angle) * this.radius
                    );
                }
            }
            
            ctx.fill();
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            
            if (!this.isDashing && Date.now() - this.lastDashTime >= this.dashCooldown) {
                if (gameObjects.paddle && Math.random() < 0.1) {
                    // Dash towards player
                    this.isDashing = true;
                    this.lastDashTime = Date.now();
                    
                    const angleToPlayer = Math.atan2(
                        gameObjects.paddle.y - this.y,
                        gameObjects.paddle.x - this.x
                    );
                    
                    this.dx = Math.cos(angleToPlayer) * this.dashSpeed;
                    this.dy = Math.sin(angleToPlayer) * this.dashSpeed;
                    
                    // Create dash effect particles
                    createParticles(this.x, this.y, "#ff0000", 10);
                    
                    // Reset after dash
                    setTimeout(() => {
                        this.isDashing = false;
                        this.dx = this.originalSpeed.dx;
                        this.dy = this.originalSpeed.dy;
                    }, 500);
                }
            }
        }
    }

    class PrismBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 40, dx, dy, "prism");
            this.colors = [
                "#ff0000", "#ff7f00", "#ffff00",
                "#00ff00", "#0000ff", "#4b0082", "#8f00ff"
            ];
            this.currentColorIndex = 0;
            this.colorChangeInterval = 100;
            this.lastColorChange = 0;
            this.splitCount = this.colors.length;
        }

        draw() {
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            
            // Create rainbow gradient
            const gradient = ctx.createLinearGradient(
                this.x - this.radius, this.y - this.radius,
                this.x + this.radius, this.y + this.radius
            );
            this.colors.forEach((color, i) => {
                gradient.addColorStop(i / (this.colors.length - 1), color);
            });
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add prismatic effect
            ctx.strokeStyle = this.colors[this.currentColorIndex];
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Add light refraction effect
            ctx.beginPath();
            ctx.arc(
                this.x - this.radius * 0.3,
                this.y - this.radius * 0.3,
                this.radius * 0.2,
                0, Math.PI * 2
            );
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.fill();
            
            ctx.closePath();
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            
            if (Date.now() - this.lastColorChange > this.colorChangeInterval) {
                this.currentColorIndex = (this.currentColorIndex + 1) % this.colors.length;
                this.lastColorChange = Date.now();
            }
        }

        split() {
            const newBubbles = [];
            for (let i = 0; i < this.splitCount; i++) {
                const angle = (i * 2 * Math.PI) / this.splitCount;
                const newDx = Math.cos(angle) * 3 * difficultyFactor;
                const newDy = Math.sin(angle) * 3 * difficultyFactor;
                const newBubble = new Bubble(this.x, this.y, 15, newDx, newDy, "tiny");
                newBubble.color = this.colors[i];
                newBubbles.push(newBubble);
            }
            return newBubbles;
        }
    }

    class RainbowBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 35, dx, dy, "rainbow");
            this.colorIndex = 0;
            this.colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8f00ff'];
            this.colorChangeSpeed = 100;
            this.lastColorChange = Date.now();
            this.splitCount = 7;
        }

        draw() {
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            
            // Create rainbow gradient
            const gradient = ctx.createRadialGradient(
                this.x, this.y, 0,
                this.x, this.y, this.radius
            );
            gradient.addColorStop(0, this.colors[this.colorIndex]);
            gradient.addColorStop(1, this.colors[(this.colorIndex + 1) % this.colors.length]);
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            if (Date.now() - this.lastColorChange > this.colorChangeSpeed) {
                this.colorIndex = (this.colorIndex + 1) % this.colors.length;
                this.lastColorChange = Date.now();
            }
        }

        split() {
            const newBubbles = [];
            for (let i = 0; i < this.splitCount; i++) {
                const angle = (i * 2 * Math.PI) / this.splitCount;
                const newDx = Math.cos(angle) * 3 * difficultyFactor;
                const newDy = Math.sin(angle) * 3 * difficultyFactor;
                const newBubble = new Bubble(this.x, this.y, 15, newDx, newDy, "tiny");
                newBubble.color = this.colors[i];
                newBubbles.push(newBubble);
            }
            return newBubbles;
        }
    }

    class MagnetBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 40, dx, dy, "magnet");
            this.attractRadius = 150;
            this.attractForce = 0.5;
            this.pulseSize = 0;
            this.pulseSpeed = 0.1;
        }

        draw() {
            ctx.save();
            // Draw magnetic field effect
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.attractRadius + this.pulseSize, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                this.x, this.y, this.radius,
                this.x, this.y, this.attractRadius + this.pulseSize
            );
            gradient.addColorStop(0, 'rgba(138, 43, 226, 0.2)');
            gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw main bubble
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#8a2be2';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            this.pulseSize = Math.sin(Date.now() * this.pulseSpeed) * 20;

            // Attract nearby bubbles
        gameObjects.bubbles.forEach(bubble => {
                if (bubble !== this) {
            const dx = this.x - bubble.x;
            const dy = this.y - bubble.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < this.attractRadius) {
                        const force = (1 - distance / this.attractRadius) * this.attractForce;
              bubble.dx += (dx / distance) * force;
              bubble.dy += (dy / distance) * force;
            }
          }
        });
      }
    }

    class PhantomBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 30, dx, dy, "phantom");
            this.opacity = 1;
            this.fadeSpeed = 0.02;
            this.visible = true;
            this.phaseTimer = 0;
            this.phaseDuration = 2000;
        }

      draw() {
            if (!this.visible) return;
            
        ctx.save();
            ctx.globalAlpha = this.opacity;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#4169e1';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add ghostly trail effect
            const trailCount = 3;
            for (let i = 1; i <= trailCount; i++) {
                ctx.globalAlpha = this.opacity * (1 - i / trailCount);
        ctx.beginPath();
                ctx.arc(
                    this.x - this.dx * i * 2,
                    this.y - this.dy * i * 2,
                    this.radius * (1 - i * 0.1),
                    0,
                    Math.PI * 2
                );
        ctx.fill();
            }
            
            ctx.closePath();
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            this.phaseTimer += dt * 1000;
            
            if (this.phaseTimer >= this.phaseDuration) {
                this.visible = !this.visible;
                this.phaseTimer = 0;
            }
            
            if (this.visible) {
                this.opacity = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
            }
        }
    }

    class TimeBubble extends Bubble {
        constructor(x, y, dx, dy) {
            super(x, y, 45, dx, dy, "time");
            this.clockRotation = 0;
            this.timeEffect = 1;
            this.pulseSize = 0;
        }

        draw() {
            ctx.save();
            
            // Draw time distortion effect
        ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + this.pulseSize, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                this.x, this.y, this.radius,
                this.x, this.y, this.radius + this.pulseSize
            );
            gradient.addColorStop(0, 'rgba(0, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
            ctx.fillStyle = gradient;
        ctx.fill();

            // Draw main bubble
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff';
            ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
            ctx.stroke();

            // Draw clock hands
            ctx.translate(this.x, this.y);
            ctx.rotate(this.clockRotation);
        ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -this.radius * 0.7);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
        ctx.stroke();
            
            ctx.restore();
        }

        update(dt) {
            super.update(dt);
            this.clockRotation += dt * 5;
            this.pulseSize = Math.sin(Date.now() * 0.005) * 10;
            
            // Apply time effect to nearby bubbles
            gameObjects.bubbles.forEach(bubble => {
                if (bubble !== this) {
                    const dx = this.x - bubble.x;
                    const dy = this.y - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 100) {
                        bubble.dx *= 0.98;
                        bubble.dy *= 0.98;
                    }
                }
            });
        }
    }

    // Update spawnRandomBubble function to include new bubble types
    function spawnRandomBubble(playArea) {
        let x = playArea.x + 50 + Math.random() * (playArea.width - 100);
        let y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
        let dx = (Math.random() < 0.5 ? -1 : 1) * (1 + Math.random() * 1.5);
        let dy = -(2 + Math.random() * 2);

        const bubbleTypes = [
            { type: "normal", weight: 40 },
            { type: "phase", weight: 10 },
            { type: "cluster", weight: 10 },
            { type: "ninja", weight: 10 },
            { type: "prism", weight: 5 },
            { type: "rainbow", weight: 5 },
            { type: "magnet", weight: 5 },
            { type: "phantom", weight: 5 },
            { type: "time", weight: 5 },
            { type: "shatter", weight: 5 }
        ];

        const totalWeight = bubbleTypes.reduce((sum, type) => sum + type.weight, 0);
        let random = Math.random() * totalWeight;
        let selectedType = bubbleTypes[0].type;

        for (const bubbleType of bubbleTypes) {
            if (random < bubbleType.weight) {
                selectedType = bubbleType.type;
                break;
            }
            random -= bubbleType.weight;
        }

        switch (selectedType) {
            case "rainbow":
                return new RainbowBubble(x, y, dx, dy);
            case "magnet":
                return new MagnetBubble(x, y, dx, dy);
            case "phantom":
                return new PhantomBubble(x, y, dx, dy);
            case "time":
                return new TimeBubble(x, y, dx, dy);
            case "phase":
                return new PhaseBubble(x, y, dx, dy);
            case "cluster":
                return new ClusterBubble(x, y, dx, dy);
            case "ninja":
                return new NinjaBubble(x, y, dx, dy);
            case "prism":
                return new PrismBubble(x, y, dx, dy);
            case "shatter":
                return new ShatterBubble(x, y, dx, dy);
            default:
                let radius = (8 + Math.random() * 10);
                return new Bubble(x, y, radius, dx, dy, "small", "normal");
        }
    }

    // Add helper functions for collision handling
    function handleBubblePaddleCollision(bubble, bubbleIndex) {
        if (gameObjects.paddle.powerOrbActive) {
            gameObjects.bubbles.splice(bubbleIndex, 1);
            score += 50;
            xp += 50;
            createParticles(bubble.x, bubble.y, "#ff00ff", 30);
            return;
        }
        
        if (!shieldActive && !paddleInvulnerable) {
            if (gameObjects.paddle.extraHit) {
                gameObjects.paddle.extraHit = false;
                showGameMessage("Extra hit absorbed!");
            } else {
                lives--;
                combo = 0;
                createParticles(gameObjects.paddle.x + gameObjects.paddle.width / 2, gameObjects.paddle.y, "#ff0000");
                if (sfxOn) audioPop.play();
                paddleInvulnerable = true;
                setTimeout(() => { paddleInvulnerable = false; }, HIT_COOLDOWN);
                addAchievement("Ouch! You took damage.");
            }
        }
        
        if (lives <= 0) {
            endGame();
        }
    }

    function handleBubbleProjectileCollision(bubble, bubbleIndex, projectile, projectileIndex) {
        gameObjects.projectiles.splice(projectileIndex, 1);
        
        if (bubble instanceof BossBubble) {
            handleBossBubbleHit(bubble, bubbleIndex);
        } else if (bubble instanceof GoldenBubble) {
            handleGoldenBubbleHit(bubble, bubbleIndex);
        } else {
            handleRegularBubbleHit(bubble, bubbleIndex);
        }
    }

    // Add these helper functions after the existing code

    function handleBossBubbleHit(bubble, bubbleIndex) {
        bubble.health--;
        bubble.lastHitTime = Date.now();
        
        if (bubble.health > 0) {
            // Different effects based on boss type
            if (bubble instanceof SplitBossBubble) {
                // Split boss already handles splitting in its update method
                createParticles(bubble.x, bubble.y, "#800080");
            } else if (bubble instanceof TeleportingBossBubble) {
                bubble.teleport();
            } else if (bubble instanceof LaserBossBubble) {
                // Trigger immediate laser attack when hit
                bubble.startChargingLaser();
            } else {
                // Original boss behavior
                for (let k = 0; k < 2; k++) {
                    let angle = -Math.PI / 2 + (k === 0 ? -0.2 : 0.2);
                    let dx = Math.cos(angle) * 3 * difficultyFactor;
                    let dy = Math.sin(angle) * 3 * difficultyFactor;
                    gameObjects.bubbles.push(new MiniBossBubble(bubble.x, bubble.y, dx, dy));
                }
            }
        } else {
            // Boss defeated
            gameObjects.bubbles.splice(bubbleIndex, 1);
            addAchievement("Boss Defeated!");
            let scoreIncrement = 50 * combo;
            score += scoreIncrement;
            xp += scoreIncrement;
            checkLevelUp();
            
            // Special defeat effects based on boss type
            if (bubble instanceof LaserBossBubble) {
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5;
                    createParticles(bubble.x, bubble.y, "#FF4500", 10, angle);
                }
            } else if (bubble instanceof TeleportingBossBubble) {
                createParticles(bubble.x, bubble.y, "#4B0082", 15);
                gameObjects.explosions.push(new Explosion(bubble.x - 30, bubble.y - 30, "teleportExplode", 8));
            } else if (bubble instanceof SplitBossBubble) {
                createParticles(bubble.x, bubble.y, "#800080", 12);
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 * i) / 4;
                    const speed = 3 * difficultyFactor;
                    const dx = Math.cos(angle) * speed;
                    const dy = Math.sin(angle) * speed;
                    gameObjects.bubbles.push(new Bubble(bubble.x, bubble.y, 20, dx, dy, "small"));
                }
            }
            
            // Common defeat effects
            gameObjects.explosions.push(new Explosion(bubble.x - 25, bubble.y - 25, "bubbleExplode", 8));
            gameObjects.explosions.push(new Explosion(bubble.x - 30, bubble.y - 30, "explosion11", 11));
            gameObjects.speechBubbles.push(new SpeechBubble(bubble.x, bubble.y - 50, "Noooo!"));

            // Check if this was the last bubble
            if (gameObjects.bubbles.length === 0) {
                clearInterval(timerInterval);
                roundTransitionInProgress = true;
                setTimeout(() => {
                    startRoundTransition();
                }, 1000);
            }
        }
    }

    function handleGoldenBubbleHit(bubble, bubbleIndex) {
        bubble.health--;
        bubble.lastHitTime = Date.now();
        spawnDrop(bubble.x, bubble.y);
        
        if (bubble.health <= 0) {
            gameObjects.bubbles.splice(bubbleIndex, 1);
            addAchievement("Golden Bubble Defeated!");
            for (let k = 0; k < 3; k++) {
                spawnDrop(bubble.x, bubble.y);
            }
            score += 200 * difficultyFactor;
            xp += 200;
            checkLevelUp();
            createParticles(bubble.x, bubble.y, "#ffd700");
            if (sfxOn) audioPop.play();

            // Check if this was the last bubble
            if (gameObjects.bubbles.length === 0) {
                clearInterval(timerInterval); // Stop the timer immediately
                roundTransitionInProgress = true;
                setTimeout(() => {
                    startRoundTransition();
                }, 1000);
            }
        }
    }

    function handleRegularBubbleHit(bubble, bubbleIndex) {
        if (bubble.type === "explosive") {
            handleExplosiveBubbleHit(bubble, bubbleIndex);
        } else if (bubble.type === "teleporting") {
            handleTeleportingBubbleHit(bubble, bubbleIndex);
        } else {
            handleNormalBubbleHit(bubble, bubbleIndex);
        }
    }

    function handleExplosiveBubbleHit(bubble, bubbleIndex) {
        const explosionRadius = 100;
        gameObjects.bubbles.forEach(otherBubble => {
            if (otherBubble !== bubble && !(otherBubble instanceof BossBubble || otherBubble instanceof GoldenBubble)) {
                const dx = otherBubble.x - bubble.x;
                const dy = otherBubble.y - bubble.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < explosionRadius) {
                    const index = gameObjects.bubbles.indexOf(otherBubble);
                    if (index > -1) {
                        gameObjects.bubbles.splice(index, 1);
                        createParticles(otherBubble.x, otherBubble.y, "#ff0000");
                        score += 10;
                    }
                }
            }
        });
        gameObjects.bubbles.splice(bubbleIndex, 1);
        createParticles(bubble.x, bubble.y, "#ff0000");
    }

    function handleTeleportingBubbleHit(bubble, bubbleIndex) {
        let dialogue = whiteBubbleDialogues[Math.floor(Math.random() * whiteBubbleDialogues.length)];
        gameObjects.speechBubbles.push(new SpeechBubble(bubble.x, bubble.y - 50, dialogue));
        
        if (bubble.teleportsLeft > 0) {
            const playArea = getPlayArea();
            bubble.x = playArea.x + 50 + Math.random() * (playArea.width - 100);
            bubble.y = playArea.y + 50 + Math.random() * ((playArea.height / 2) - 50);
            bubble.teleportsLeft--;
            createParticles(bubble.x, bubble.y, "#ffffff");
        } else {
            handleNormalBubbleHit(bubble, bubbleIndex);
        }
    }

    function handleNormalBubbleHit(bubble, bubbleIndex) {
        combo++;
        let scoreIncrement = 10 * combo * difficultyFactor;
        score += scoreIncrement;
        xp += scoreIncrement;
        checkLevelUp();
        createParticles(bubble.x, bubble.y, "#00ff00");
        if (sfxOn) audioPop.play();
        
        const dropChance = 0.05 + (level * 0.03 * difficultyFactor);
        if (Math.random() < dropChance) {
            spawnDrop(bubble.x, bubble.y);
        }
        
        splitBubble(bubble, bubbleIndex);
        
        if (combo % 5 === 0) {
            addAchievement("Combo x" + combo + "!");
        }

        // Check if this was the last bubble
        if (gameObjects.bubbles.length === 0) {
            clearInterval(timerInterval); // Stop the timer immediately
            roundTransitionInProgress = true;
            setTimeout(() => {
                startRoundTransition();
            }, 1000);
        }
    }

    function updateDrops(effectiveDelta) {
        for (let i = gameObjects.drops.length - 1; i >= 0; i--) {
            const drop = gameObjects.drops[i];
            drop.update(effectiveDelta);
            drop.draw();
            
            const dropRect = { x: drop.x, y: drop.y, width: drop.width, height: drop.height };
            const paddleRect = gameObjects.paddle.getHitbox();
            
            if (isCollidingRect(dropRect, paddleRect)) {
                processDropCollision(drop);
                itemLog.push(drop.type);
                gameObjects.drops.splice(i, 1);
                createParticles(drop.x, drop.y, "#ffff00", 25);
                if (sfxOn) audioPowerup.play();
            } else if (drop.y > getPlayArea().y + getPlayArea().height) {
                gameObjects.drops.splice(i, 1);
            }
        }
    }

    function updateParticles(effectiveDelta) {
        for (let i = gameObjects.particles.length - 1; i >= 0; i--) {
            const p = gameObjects.particles[i];
            p.update(effectiveDelta);
            p.draw();
            if (p.life <= 0) {
                gameObjects.particles.splice(i, 1);
            }
        }
    }

    function updateExplosions(effectiveDelta) {
        for (let i = gameObjects.explosions.length - 1; i >= 0; i--) {
            const exp = gameObjects.explosions[i];
            exp.update();
            exp.draw();
            if (exp.isFinished()) {
                gameObjects.explosions.splice(i, 1);
            }
        }
    }

    function updateSpeechBubbles(effectiveDelta) {
        for (let i = gameObjects.speechBubbles.length - 1; i >= 0; i--) {
            const bubble = gameObjects.speechBubbles[i];
            bubble.draw();
            if (Date.now() - bubble.startTime > bubble.duration) {
                gameObjects.speechBubbles.splice(i, 1);
            }
        }
    }

    // Add to the script section
    let isMobileMode = false;

    // Mobile mode toggle handlers
    document.getElementById("mobileToggle").addEventListener("change", (e) => {
        isMobileMode = e.target.checked;
        document.getElementById("mobileToggleSettings").checked = isMobileMode;
        toggleMobileMode(isMobileMode);
    });

    document.getElementById("mobileToggleSettings").addEventListener("change", (e) => {
        isMobileMode = e.target.checked;
        document.getElementById("mobileToggle").checked = isMobileMode;
        toggleMobileMode(isMobileMode);
    });

    function toggleMobileMode(enabled) {
        const mainContainer = document.getElementById('mainContainer');
        const mobileControls = document.getElementById('mobileControls');
        
        if (enabled) {
            mainContainer.classList.add('mobile-mode');
            mobileControls.style.display = 'flex';
            setupMobileControls();
        } else {
            mainContainer.classList.remove('mobile-mode');
            mobileControls.style.display = 'none';
            removeMobileControls();
        }
        
        adjustCanvasSize();
    }

    function setupMobileControls() {
        const mobileControls = document.getElementById('mobileControls');
        if (!mobileControls) return;

        // Prevent default behaviors
        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#gameCanvas')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Prevent iOS double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Control button handling
        const buttons = mobileControls.querySelectorAll('.control-button');
        buttons.forEach(button => {
            let isPressed = false;
            let action = button.dataset.action;

            const handleStart = (e) => {
                e.preventDefault();
                if (isPressed) return;
                isPressed = true;
                
                switch(action) {
                    case 'move-left':
                        leftPressed = true;
                        if (gameObjects.paddle) gameObjects.paddle.direction = "left";
                        break;
                    case 'move-right':
                        rightPressed = true;
                        if (gameObjects.paddle) gameObjects.paddle.direction = "right";
                        break;
                    case 'jump':
                        if (gameObjects.paddle) gameObjects.paddle.jump();
                        break;
                    case 'shoot':
                        shootProjectile();
                        button.shootInterval = setInterval(shootProjectile, 200);
                        break;
                    case 'backpack':
                        const items = Object.entries(backpackInventory);
                        if (items.length > 0) useBackpackItem(items[0][0]);
                        break;
                }
                
                button.style.transform = 'scale(0.9) translateZ(0)';
            };

            const handleEnd = (e) => {
                e.preventDefault();
                isPressed = false;
                
                switch(action) {
                    case 'move-left':
                        leftPressed = false;
                        break;
                    case 'move-right':
                        rightPressed = false;
                        break;
                    case 'shoot':
                        if (button.shootInterval) {
                            clearInterval(button.shootInterval);
                            button.shootInterval = null;
                        }
                        break;
                }
                
                button.style.transform = 'translateZ(0)';
            };

            // Add touch event listeners
            button.addEventListener('touchstart', handleStart, { passive: false });
            button.addEventListener('touchend', handleEnd, { passive: false });
            button.addEventListener('touchcancel', handleEnd, { passive: false });
        });
    }

    // iOS Detection
    function isIOS() {
        return [
            'iPad Simulator',
            'iPhone Simulator',
            'iPod Simulator',
            'iPad',
            'iPhone',
            'iPod'
        ].includes(navigator.platform)
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
    }

    // Mobile Detection with iOS specifics
    function isMobileDevice() {
        const mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const iOS = isIOS();
        const isSmallScreen = window.innerWidth <= 768;
        return mobile || iOS || isSmallScreen;
    }

    // Update view mode handling
    function updateViewMode() {
        const mainContainer = document.getElementById('mainContainer');
        const mobileControls = document.getElementById('mobileControls');
        const isMobile = isMobileDevice();
        
        if (isMobile) {
            document.body.classList.add('mobile-mode');
            mainContainer.classList.add('mobile-mode');
            mobileControls.style.display = 'block';
            setupMobileControls();
            
            // iOS specific adjustments
            if (isIOS()) {
                document.documentElement.style.height = '100%';
                document.body.style.height = '-webkit-fill-available';
                window.scrollTo(0, 0);
            }
        } else {
            document.body.classList.remove('mobile-mode');
            mainContainer.classList.remove('mobile-mode');
            mobileControls.style.display = 'none';
        }
        
        adjustCanvasSize();
        updateBackpackUI();
    }

    // Add resize handling for orientation changes
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            updateViewMode();
            if (isMobileDevice()) {
                window.scrollTo(0, 0);
            }
        }, 250);
    });

    function removeMobileControls() {
        // Remove touch event listeners if needed
        const buttons = document.querySelectorAll(".control-button");
        buttons.forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
    }

    // Update the shooting controls
    document.addEventListener("keydown", function (e) {
        if (gamePaused || currentState !== GameState.PLAYING) return;
        
        const key = e.key.toLowerCase();
        if (key === controlRight || e.key === "arrowright") {
            rightPressed = true;
            if (gameObjects.paddle) gameObjects.paddle.direction = "right";
        }
        else if (key === controlLeft || e.key === "arrowleft") {
            leftPressed = true;
            if (gameObjects.paddle) gameObjects.paddle.direction = "left";
        }
        else if (key === controlShoot || key === " " || e.code === "Space") {
            e.preventDefault();
            shootProjectile();
        }
        else if (key === "w") {
            if (gameObjects.paddle) gameObjects.paddle.jump();
        }
        else if (key === "s") {
            const backpackGrid = document.getElementById("backpackGrid");
            if (backpackGrid && backpackGrid.children.length > 0) {
              const firstSlot = backpackGrid.children[0];
              const itemType = firstSlot.dataset.itemType;
              if (itemType) {
                useBackpackItem(itemType);
              }
            }
        }
    });

    // Add mouse click handler for shooting
    document.getElementById("gameCanvas").addEventListener("click", function(e) {
        e.preventDefault();
        if (gamePaused || currentState !== GameState.PLAYING) return;
        shootProjectile();
    });

    // Enhanced level design - Add new bubble patterns
    function spawnBubblePattern(pattern, playArea) {
        switch(pattern) {
            case "circle":
                spawnCirclePattern(playArea);
                break;
            case "wave":
                spawnWavePattern(playArea);
                break;
            case "spiral":
                spawnSpiralPattern(playArea);
                break;
            case "zigzag":
                spawnZigzagPattern(playArea);
                break;
            case "mixed":
                // Randomly choose two patterns to combine
                const patterns = ["circle", "wave", "spiral", "zigzag"];
                const pattern1 = patterns[Math.floor(Math.random() * patterns.length)];
                let pattern2;
                do {
                    pattern2 = patterns[Math.floor(Math.random() * patterns.length)];
                } while (pattern2 === pattern1);
                
                spawnBubblePattern(pattern1, playArea);
                spawnBubblePattern(pattern2, playArea);
                break;
            case "figure-8":
                spawnFigure8Pattern(playArea);
                break;
        }
    }

    function spawnCirclePattern(playArea) {
        const centerX = playArea.x + playArea.width / 2;
        const centerY = playArea.y + playArea.height / 3;
        const radius = Math.min(playArea.width, playArea.height) / 4;
        const count = 8;
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            const dx = Math.cos(angle) * 2 * difficultyFactor;
            const dy = Math.sin(angle) * 2 * difficultyFactor;
            gameObjects.bubbles.push(new Bubble(x, y, 20, dx, dy, "medium"));
        }
    }

    function spawnWavePattern(playArea) {
        const startX = playArea.x + 50;
        const startY = playArea.y + 100;
        const count = 10;
        
        for (let i = 0; i < count; i++) {
            const x = startX + (i / count) * (playArea.width - 100);
            const y = startY + Math.sin(i * 0.5) * 50;
            const dx = Math.sin(i * 0.5) * 2 * difficultyFactor;
            const dy = -2 * difficultyFactor;
            gameObjects.bubbles.push(new Bubble(x, y, 15, dx, dy, "small"));
        }
    }

    function spawnSpiralPattern(playArea) {
        const centerX = playArea.x + playArea.width / 2;
        const centerY = playArea.y + playArea.height / 3;
        const count = 12;
        
        for (let i = 0; i < count; i++) {
            const radius = (i / count) * Math.min(playArea.width, playArea.height) / 3;
            const angle = (i / count) * Math.PI * 4;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            const dx = Math.cos(angle) * 2 * difficultyFactor;
            const dy = Math.sin(angle) * 2 * difficultyFactor;
            gameObjects.bubbles.push(new Bubble(x, y, 18, dx, dy, "medium"));
        }
    }

    function spawnZigzagPattern(playArea) {
        const startX = playArea.x + 50;
        const startY = playArea.y + 100;
        const count = 8;
        const amplitude = 80;
        
        for (let i = 0; i < count; i++) {
            const x = startX + (i / count) * (playArea.width - 100);
            const y = startY + (i % 2 === 0 ? amplitude : -amplitude);
            const dx = (i % 2 === 0 ? 1 : -1) * 2 * difficultyFactor;
            const dy = -2 * difficultyFactor;
            gameObjects.bubbles.push(new Bubble(x, y, 15, dx, dy, "small"));
        }
    }

    function spawnFigure8Pattern(playArea) {
        const centerX = playArea.x + playArea.width / 2;
        const centerY = playArea.y + playArea.height / 2;
        const radius = Math.min(playArea.width, playArea.height) / 4;
        const count = 16;
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * radius * (1 + Math.sin(angle));
            const y = centerY + Math.sin(angle) * radius * (1 + Math.cos(angle));
            const dx = Math.cos(angle) * 2 * difficultyFactor;
            const dy = Math.sin(angle) * 2 * difficultyFactor;
            gameObjects.bubbles.push(new Bubble(x, y, 20, dx, dy, "medium"));
        }
    }

    function toggleControlPanel() {
        const panel = document.getElementById('topButtons');
        panel.classList.toggle('minimized');
        const button = panel.querySelector('.minimize-button');
        button.textContent = panel.classList.contains('minimized') ? '▲' : '▼';
    }

    // Platform Classes
    class Platform {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = "#46fbe3";
            this.borderColor = "#ff5fd4";
            this.glowIntensity = 0;
            this.glowDirection = 1;
        }

        draw(ctx) {
            ctx.save();
            
            // Platform glow effect
            this.glowIntensity += 0.02 * this.glowDirection;
            if (this.glowIntensity >= 1) this.glowDirection = -1;
            if (this.glowIntensity <= 0) this.glowDirection = 1;
            
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10 + (this.glowIntensity * 5);
            
            // Main platform body
            ctx.fillStyle = "rgba(70, 251, 227, 0.3)";
            ctx.strokeStyle = this.borderColor;
            ctx.lineWidth = 2;
            
            // Draw platform with rounded corners
        ctx.beginPath();
            ctx.roundRect(this.x, this.y, this.width, this.height, 5);
            ctx.fill();
            ctx.stroke();
            
            // Add neon line detail
            ctx.beginPath();
            ctx.moveTo(this.x + 10, this.y + this.height/2);
            ctx.lineTo(this.x + this.width - 10, this.y + this.height/2);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }
    }

    class MovingPlatform extends Platform {
        constructor(x, y, width, height, movePattern) {
            super(x, y, width, height);
            this.startX = x;
            this.startY = y;
            this.movePattern = movePattern;
            this.time = 0;
            this.speed = 2;
        }

        update(dt) {
            this.time += dt;
            
            switch(this.movePattern) {
                case "horizontal":
                    this.x = this.startX + Math.sin(this.time * this.speed) * 100;
                    break;
                case "vertical":
                    this.y = this.startY + Math.sin(this.time * this.speed) * 50;
                    break;
                case "circular":
                    this.x = this.startX + Math.cos(this.time * this.speed) * 50;
                    this.y = this.startY + Math.sin(this.time * this.speed) * 50;
                    break;
                case "zigzag":
                    this.x = this.startX + Math.sin(this.time * this.speed * 2) * 50;
                    this.y = this.startY + Math.sin(this.time * this.speed) * 30;
                    break;
            }
        }
    }

    // Level Design Functions
    let staticPlatforms = [];
    let movingPlatforms = [];

    function generateLevelPlatforms(level, playArea) {
        staticPlatforms = [];
        movingPlatforms = [];
        
        const platformHeight = 15;
        const minPlatformWidth = 60;
        const maxPlatformWidth = 150;
        
        // Basic platform patterns based on level
        if (level % 10 === 0) {
            // Boss level - minimal platforms
            generateBossLevelPlatforms(playArea);
        } else if (level % 5 === 0) {
            // Special level - complex moving platforms
            generateSpecialLevelPlatforms(playArea);
        } else {
            // Regular level
            generateRegularLevelPlatforms(level, playArea);
        }
    }

    function generateBossLevelPlatforms(playArea) {
        // Add few strategic platforms for boss fights
        const platformHeight = 15;
        
        // Two side platforms
        staticPlatforms.push(new Platform(
            playArea.x + 50,
            playArea.y + playArea.height * 0.6,
            100,
            platformHeight
        ));
        
        staticPlatforms.push(new Platform(
            playArea.x + playArea.width - 150,
            playArea.y + playArea.height * 0.6,
            100,
            platformHeight
        ));
        
        // One moving platform in the middle
        movingPlatforms.push(new MovingPlatform(
            playArea.x + playArea.width/2 - 75,
            playArea.y + playArea.height * 0.4,
            150,
            platformHeight,
            "vertical"
        ));
    }

    function generateSpecialLevelPlatforms(playArea) {
        const platformHeight = 15;
        
        // Create a complex pattern of moving platforms
        const patterns = ["horizontal", "vertical", "circular", "zigzag"];
        
        for (let i = 0; i < 4; i++) {
            movingPlatforms.push(new MovingPlatform(
                playArea.x + (playArea.width * (i + 1))/5 - 50,
                playArea.y + playArea.height * (0.3 + i * 0.15),
                100,
                platformHeight,
                patterns[i]
            ));
        }
        
        // Add some static platforms for safety
        staticPlatforms.push(new Platform(
            playArea.x + 50,
            playArea.y + playArea.height * 0.7,
            100,
            platformHeight
        ));
        
        staticPlatforms.push(new Platform(
            playArea.x + playArea.width - 150,
            playArea.y + playArea.height * 0.7,
            100,
            platformHeight
        ));
    }

    function generateRegularLevelPlatforms(level, playArea) {
        const platformHeight = 15;
        const platformCount = Math.min(3 + Math.floor(level/2), 8);
        
        // Create a mix of static and moving platforms
        for (let i = 0; i < platformCount; i++) {
            const width = 80 + Math.random() * 70;
            const x = playArea.x + 50 + (Math.random() * (playArea.width - width - 100));
            const y = playArea.y + playArea.height * (0.3 + (i * 0.15));
            
            if (Math.random() < 0.3) {
                // 30% chance for moving platform
                movingPlatforms.push(new MovingPlatform(
                    x, y, width, platformHeight,
                    ["horizontal", "vertical", "zigzag"][Math.floor(Math.random() * 3)]
                ));
            } else {
                staticPlatforms.push(new Platform(x, y, width, platformHeight));
            }
        }
    }

    // Update the game loop to include platform updates and drawing
    function updateAndDrawPlatforms(dt) {
        // Update moving platforms
        movingPlatforms.forEach(platform => {
            platform.update(dt);
            platform.draw(ctx);
        });
        
        // Draw static platforms
        staticPlatforms.forEach(platform => platform.draw(ctx));
    }

    // Add to the gameLoop function after drawing the background
    // ... existing gameLoop code ...
    drawGameBackdrop(playArea);
    updateAndDrawPlatforms(effectiveDelta);  // Add this line
    // ... rest of gameLoop code ...
  })();
    </script>
    <!-- Confirmation Modal -->
    <div id="scoreConfirmModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:300; justify-content:center; align-items:center;">
        <div style="background:#222; padding:20px; border:2px solid var(--accent-color); border-radius:10px; color:#fff; text-align:center;">
            <p>Submit your score to the leaderboard?</p>
            <button id="confirmScoreSubmit">Yes</button>
            <button id="cancelScoreSubmit">No</button>
        </div>
    </div>
</body>
</html>
